[
  {
    "id": "reverseList",
    "title": "反转链表",
    "description": "将链表中的节点顺序反转，使尾节点成为头节点",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "coreIdea": "使用三个指针（prev, current, next）遍历链表并改变指向。prev初始为null，current指向当前节点，next保存下一个节点。每次迭代将current.next指向prev，然后移动指针继续遍历。",
    "codeSnippet": "function reverseList(head) {\n  let prev = null;\n  let current = head;\n  while (current) {\n    const next = current.next;\n    current.next = prev;\n    prev = current;\n    current = next;\n  }\n  return prev;\n}",
    "difficulty": "easy",
    "type": ["反转", "遍历", "双(三)指针"]
  },
  {
    "id": "mergeTwoLists",
    "title": "合并两个有序链表",
    "description": "将两个升序链表合并为一个新的升序链表",
    "timeComplexity": "O(n+m)",
    "spaceComplexity": "O(1)",
    "coreIdea": "使用虚拟头节点简化边界处理，比较两个链表当前节点值，将较小值的节点连接到结果链表，并移动对应指针。当其中一个链表遍历完毕时，将剩余链表直接连接。",
    "codeSnippet": "function mergeTwoLists(l1, l2) {\n  const dummy = new ListNode(-1);\n  let current = dummy;\n  while (l1 && l2) {\n    if (l1.val < l2.val) {\n      current.next = l1;\n      l1 = l1.next;\n    } else {\n      current.next = l2;\n      l2 = l2.next;\n    }\n    current = current.next;\n  }\n  current.next = l1 || l2;\n  return dummy.next;\n}",
    "difficulty": "easy",
    "type": ["遍历", "归并", "双(三)指针", "虚拟头节点"]
  },
  {
    "id": "middleNode",
    "title": "链表的中间结点",
    "description": "找到链表的中间节点，如果有两个中间节点则返回第二个",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "coreIdea": "使用快慢指针技术，快指针每次移动两步，慢指针每次移动一步。当快指针到达链表末尾时，慢指针正好指向中间节点。这种方法的优势是只需要一次遍历就能找到中点。",
    "codeSnippet": "function middleNode(head) {\n  let slow = head;\n  let fast = head;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  return slow;\n}",
    "difficulty": "easy",
    "type": ["遍历", "查找", "快慢指针"]
  },
  {
    "id": "removeNthFromEnd",
    "title": "删除链表的倒数第N个结点",
    "description": "删除链表的倒数第n个节点并返回头节点",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "coreIdea": "使用双指针技巧，先让快指针向前移动n+1步，然后快慢指针同时移动。当快指针到达末尾时，慢指针正好指向要删除节点的前一个节点。使用虚拟头节点处理删除头节点的情况。",
    "codeSnippet": "function removeNthFromEnd(head, n) {\n  const dummy = new ListNode(0, head);\n  let slow = dummy;\n  let fast = dummy;\n  for (let i = 0; i <= n; i++) {\n    fast = fast.next;\n  }\n  while (fast) {\n    slow = slow.next;\n    fast = fast.next;\n  }\n  slow.next = slow.next.next;\n  return dummy.next;\n}",
    "difficulty": "medium",
    "type": ["删除", "遍历", "双(三)指针"]
  },
  {
    "id": "hasCycle",
    "title": "环形链表检测",
    "description": "判断链表中是否存在环",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "coreIdea": "Floyd判圈算法（龟兔赛跑），快指针每次走两步，慢指针走一步。如果链表有环，两个指针最终会在环内相遇；如果无环，快指针会先到达末尾。这种方法不需要额外空间，时间复杂度为O(n)。",
    "codeSnippet": "function hasCycle(head) {\n  if (!head) return false;\n  let slow = head;\n  let fast = head.next;\n  while (fast && fast.next) {\n    if (slow === fast) return true;\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  return false;\n}",
    "difficulty": "easy",
    "type": ["检测", "遍历", "快慢指针","环"]
  },
  {
    "id": "detectCycle",
    "title": "环形链表入口点",
    "description": "如果链表有环，找到环的入口节点",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "coreIdea": "先使用快慢指针找到相遇点，然后一个指针从头开始，另一个从相遇点开始，两个指针都以相同速度移动。根据数学原理，它们会在环的入口点相遇。这是Floyd算法的扩展应用。",
    "codeSnippet": "function detectCycle(head) {\n  if (!head) return null;\n  let slow = head;\n  let fast = head;\n  let hasCycle = false;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n    if (slow === fast) {\n      hasCycle = true;\n      break;\n    }\n  }\n  if (!hasCycle) return null;\n  slow = head;\n  while (slow !== fast) {\n    slow = slow.next;\n    fast = fast.next;\n  }\n  return slow;\n}",
    "difficulty": "medium",
    "type": ["检测", "查找", "快慢指针","环"]
  },
  {
    "id": "getIntersectionNode",
    "title": "相交链表",
    "description": "找到两个链表相交的起始节点",
    "timeComplexity": "O(n+m)",
    "spaceComplexity": "O(1)",
    "coreIdea": "双指针分别遍历两个链表，到达尾部后交换到另一个链表头部。如果两个链表相交，两个指针最终会在相交点相遇；如果不相交，两个指针最终都会变为null。这种方法巧妙地处理了长度不同的情况。",
    "codeSnippet": "function getIntersectionNode(headA, headB) {\n  let pA = headA;\n  let pB = headB;\n  while (pA !== pB) {\n    pA = pA ? pA.next : headB;\n    pB = pB ? pB.next : headA;\n  }\n  return pA;\n}",
    "difficulty": "easy",
    "type": ["查找", "遍历", "双(三)指针"]
  },
  {
    "id": "isPalindrome",
    "title": "回文链表",
    "description": "判断链表是否为回文结构",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "coreIdea": "找到中点，反转后半部分，然后比较前后两部分。使用快慢指针找到中点，反转后半部分链表，最后用双指针比较前半部分和反转后的后半部分。这种方法在O(1)空间复杂度下完成判断。",
    "codeSnippet": "function isPalindrome(head) {\n  let slow = head;\n  let fast = head;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  let prev = null;\n  while (slow) {\n    const next = slow.next;\n    slow.next = prev;\n    prev = slow;\n    slow = next;\n  }\n  let left = head;\n  let right = prev;\n  while (right) {\n    if (left.val !== right.val) return false;\n    left = left.next;\n    right = right.next;\n  }\n  return true;\n}",
    "difficulty": "medium",
    "type": ["检测", "快慢指针", "反转"]
  },
  {
    "id": "sortList",
    "title": "链表排序",
    "description": "在O(n log n)时间复杂度和常数级空间复杂度下对链表进行排序",
    "timeComplexity": "O(n log n)",
    "spaceComplexity": "O(log n)",
    "coreIdea": "使用归并排序，先分割链表再合并。用快慢指针找到中点分割链表，递归排序两个子链表，最后合并有序链表。归并排序适合链表结构，避免了数组排序中的随机访问开销。",
    "codeSnippet": "function sortList(head) {\n  if (!head || !head.next) return head;\n  let slow = head;\n  let fast = head.next;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  const mid = slow.next;\n  slow.next = null;\n  const left = sortList(head);\n  const right = sortList(mid);\n  return merge(left, right);\n}",
    "difficulty": "medium",
    "type": ["排序", "分治", "归并", "递归"]
  },
  {
    "id": "rotateRight",
    "title": "旋转链表",
    "description": "将链表每个节点向右移动k个位置",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "coreIdea": "先成环，然后找到新的头节点并断开。计算链表长度，将尾节点指向头节点形成环，然后计算需要移动的步数，找到新的尾节点并断开环，返回新的头节点。",
    "codeSnippet": "function rotateRight(head, k) {\n  if (!head || k === 0) return head;\n  let len = 1;\n  let tail = head;\n  while (tail.next) {\n    tail = tail.next;\n    len++;\n  }\n  tail.next = head;\n  const steps = len - (k % len);\n  let newTail = head;\n  for (let i = 0; i < steps - 1; i++) {\n    newTail = newTail.next;\n  }\n  const newHead = newTail.next;\n  newTail.next = null;\n  return newHead;\n}",
    "difficulty": "medium",
    "type": ["转换", "遍历", "环"]
  },
  {
    "id": "oddEvenList",
    "title": "链表的奇偶重排",
    "description": "将链表的奇数节点和偶数节点分别排在一起",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "coreIdea": "使用两个指针，一个指向奇数节点，一个指向偶数节点。遍历链表，将奇数节点和偶数节点分别连接成两个子链表，最后将偶数链表连接到奇数链表末尾。",
    "codeSnippet": "function oddEvenList(head) {\n  if (!head || !head.next) return head;\n  let odd = head;\n  let even = head.next;\n  let evenHead = even;\n  while (even && even.next) {\n    odd.next = even.next;\n    odd = odd.next;\n    even.next = odd.next;\n    even = even.next;\n  }\n  odd.next = evenHead;\n  return head;\n}",
    "difficulty": "medium",
    "type": ["重排", "遍历", "双(三)指针"]
  },
  {
    "id": "removeDuplicates",
    "title": "删除排序链表中的重复元素",
    "description": "删除所有重复元素，使每个元素只出现一次",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "coreIdea": "遍历链表，比较当前节点与下一节点值。如果值相同，则删除下一个节点；如果值不同，则移动到下一个节点。由于链表已排序，重复元素必定相邻，这种方法简单高效。",
    "codeSnippet": "function deleteDuplicates(head) {\n  let current = head;\n  while (current && current.next) {\n    if (current.val === current.next.val) {\n      current.next = current.next.next;\n    } else {\n      current = current.next;\n    }\n  }\n  return head;\n}",
    "difficulty": "easy",
    "type": ["删除", "遍历", "去重"]
  },
  {
    "id": "removeAllDuplicates",
    "title": "删除排序链表中的重复元素 II",
    "description": "删除所有含有重复数字的节点，只保留原始链表中没有重复出现的数字",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "coreIdea": "使用虚拟头节点，双指针比较相邻节点。当发现重复元素时，跳过所有重复节点，将前一个指针直接连接到下一个不重复的节点。这种方法可以处理连续多个重复元素的情况。",
    "codeSnippet": "function deleteAllDuplicates(head) {\n  const dummy = new ListNode(0, head);\n  let prev = dummy;\n  while (head) {\n    if (head.next && head.val === head.next.val) {\n      while (head.next && head.val === head.next.val) {\n        head = head.next;\n      }\n      prev.next = head.next;\n    } else {\n      prev = prev.next;\n    }\n    head = head.next;\n  }\n  return dummy.next;\n}",
    "difficulty": "medium",
    "type": ["删除", "去重", "双(三)指针", "虚拟头节点"]
  },
  {
    "id": "addTwoNumbers",
    "title": "两数相加",
    "description": "两个非空链表表示的非负整数，每位数字逆序存储，求两数之和",
    "timeComplexity": "O(max(m,n))",
    "spaceComplexity": "O(max(m,n))",
    "coreIdea": "模拟加法运算，处理进位。遍历两个链表，对应位相加并处理进位，创建新节点存储结果。如果链表长度不同，短链表的对应位视为0。最后如果还有进位，需要创建额外的节点。",
    "codeSnippet": "function addTwoNumbers(l1, l2) {\n  const dummy = new ListNode(0);\n  let current = dummy;\n  let carry = 0;\n  \n  while (l1 || l2 || carry) {\n    const sum = (l1?.val || 0) + (l2?.val || 0) + carry;\n    carry = Math.floor(sum / 10);\n    current.next = new ListNode(sum % 10);\n    current = current.next;\n    l1 = l1?.next;\n    l2 = l2?.next;\n  }\n  return dummy.next;\n}",
    "difficulty": "medium",
    "type": ["数学运算", "遍历"]
  },
  {
    "id": "reverseBetween",
    "title": "反转链表 II",
    "description": "反转从位置left到right的链表节点",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "coreIdea": "定位反转区间，反转局部链表。先找到反转区间的前一个节点，然后使用头插法反转指定区间内的节点。头插法可以保持反转后的相对顺序，最后连接反转区间的前后部分。",
    "codeSnippet": "function reverseBetween(head, left, right) {\n  const dummy = new ListNode(0, head);\n  let prev = dummy;\n  \n  for (let i = 0; i < left - 1; i++) {\n    prev = prev.next;\n  }\n  \n  let current = prev.next;\n  for (let i = 0; i < right - left; i++) {\n    const next = current.next;\n    current.next = next.next;\n    next.next = prev.next;\n    prev.next = next;\n  }\n  \n  return dummy.next;\n}",
    "difficulty": "medium",
    "type": ["转换", "区间操作"]
  },
  {
    "id": "reorderList",
    "title": "重排链表",
    "description": "L0 → L1 → ... → Ln-1 → Ln 重排为 L0 → Ln → L1 → Ln-1 → ...",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "coreIdea": "找到中点，反转后半部分，合并两个链表。使用快慢指针找到中点，反转后半部分链表，然后交替连接前半部分和反转后的后半部分节点。这种方法可以重排链表而不需要额外空间。",
    "codeSnippet": "function reorderList(head) {\n  // 找到中点\n  let slow = head, fast = head;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  \n  // 反转后半部分\n  let prev = null, current = slow;\n  while (current) {\n    const next = current.next;\n    current.next = prev;\n    prev = current;\n    current = next;\n  }\n  \n  // 合并链表\n  let first = head, second = prev;\n  while (second.next) {\n    const temp1 = first.next;\n    const temp2 = second.next;\n    first.next = second;\n    second.next = temp1;\n    first = temp1;\n    second = temp2;\n  }\n}",
    "difficulty": "medium",
    "type": ["快慢指针", "重排", "转换", "反转", "合并"]
  },
  {
    "id": "partitionList",
    "title": "分隔链表",
    "description": "按给定值x分隔链表，所有小于x的节点都在大于等于x的节点之前",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "coreIdea": "创建两个子链表再合并。遍历原链表，将小于x的节点连接到小于链表，大于等于x的节点连接到大于链表。最后将两个链表连接，保持相对顺序不变。",
    "codeSnippet": "function partition(head, x) {\n  const dummy1 = new ListNode(0);\n  const dummy2 = new ListNode(0);\n  let p1 = dummy1, p2 = dummy2;\n  \n  while (head) {\n    if (head.val < x) {\n      p1.next = head;\n      p1 = p1.next;\n    } else {\n      p2.next = head;\n      p2 = p2.next;\n    }\n    head = head.next;\n  }\n  \n  p2.next = null;\n  p1.next = dummy2.next;\n  return dummy1.next;\n}",
    "difficulty": "medium",
    "type": ["分割", "遍历", "双(三)指针"]
  },
  {
    "id": "copyRandomList",
    "title": "复制带随机指针的链表",
    "description": "深度拷贝带有随机指针的链表",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "coreIdea": "使用哈希表存储原节点到拷贝节点的映射。第一次遍历创建所有节点，第二次遍历设置next和random指针。哈希表确保每个原节点只被拷贝一次，random指针指向正确的拷贝节点。",
    "codeSnippet": "function copyRandomList(head) {\n  if (!head) return null;\n  \n  const map = new Map();\n  let current = head;\n  \n  // 第一次遍历：创建所有节点\n  while (current) {\n    map.set(current, new Node(current.val));\n    current = current.next;\n  }\n  \n  // 第二次遍历：设置指针\n  current = head;\n  while (current) {\n    const copy = map.get(current);\n    copy.next = map.get(current.next) || null;\n    copy.random = map.get(current.random) || null;\n    current = current.next;\n  }\n  \n  return map.get(head);\n}",
    "difficulty": "medium",
    "type": ["拷贝", "遍历", "哈希表"]
  },
  {
    "id": "mergeKLists",
    "title": "合并K个升序链表",
    "description": "将k个升序链表合并为一个升序链表",
    "timeComplexity": "O(n log k)",
    "spaceComplexity": "O(1)",
    "coreIdea": "使用分治法两两合并链表。将k个链表分成两半，递归合并每一半，最后合并两个结果。分治法的时间复杂度为O(n log k)，其中n是所有链表的总节点数，k是链表数量。",
    "codeSnippet": "function mergeKLists(lists) {\n  if (!lists.length) return null;\n  \n  const mergeTwo = (l1, l2) => {\n    const dummy = new ListNode(0);\n    let current = dummy;\n    \n    while (l1 && l2) {\n      if (l1.val < l2.val) {\n        current.next = l1;\n        l1 = l1.next;\n      } else {\n        current.next = l2;\n        l2 = l2.next;\n      }\n      current = current.next;\n    }\n    \n    current.next = l1 || l2;\n    return dummy.next;\n  };\n  \n  // 分治合并\n  const mergeLists = (lists, start, end) => {\n    if (start === end) return lists[start];\n    const mid = Math.floor((start + end) / 2);\n    const left = mergeLists(lists, start, mid);\n    const right = mergeLists(lists, mid + 1, end);\n    return mergeTwo(left, right);\n  };\n  \n  return mergeLists(lists, 0, lists.length - 1);\n}",
    "difficulty": "hard",
    "type": ["归并", "分治"]
  },
  {
    "id": "reverseKGroup",
    "title": "K个一组反转链表",
    "description": "每k个节点一组进行反转，返回修改后的链表",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "coreIdea": "递归反转每组链表，连接各组。先检查是否有足够的节点进行反转，如果有则反转当前组，然后递归处理剩余部分。最后将反转后的组与剩余部分连接。",
    "codeSnippet": "function reverseKGroup(head, k) {\n  // 检查是否有足够节点\n  let count = 0;\n  let current = head;\n  while (current && count < k) {\n    current = current.next;\n    count++;\n  }\n  \n  if (count < k) return head;\n  \n  // 反转当前组\n  let prev = null, curr = head;\n  for (let i = 0; i < k; i++) {\n    const next = curr.next;\n    curr.next = prev;\n    prev = curr;\n    curr = next;\n  }\n  \n  // 连接下一组\n  head.next = reverseKGroup(curr, k);\n  return prev;\n}",
    "difficulty": "hard",
    "type": ["转换", "递归", "反转"]
  },
  {
    "id": "swapPairs",
    "title": "两两交换链表中的节点",
    "description": "交换相邻节点，不能修改节点内部值",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "coreIdea": "迭代交换相邻节点。使用虚拟头节点简化边界处理，每次交换两个相邻节点，然后移动指针到下一对。交换时需要保存引用，避免丢失节点。",
    "codeSnippet": "function swapPairs(head) {\n  const dummy = new ListNode(0, head);\n  let prev = dummy;\n  \n  while (head && head.next) {\n    const first = head;\n    const second = head.next;\n    \n    // 交换节点\n    prev.next = second;\n    first.next = second.next;\n    second.next = first;\n    \n    // 移动指针\n    prev = first;\n    head = first.next;\n  }\n  \n  return dummy.next;\n}",
    "difficulty": "medium",
    "type": ["转换", "遍历"]
  },
  {
    "id": "insertionSortList",
    "title": "链表插入排序",
    "description": "使用插入排序算法对链表排序",
    "timeComplexity": "O(n²)",
    "spaceComplexity": "O(1)",
    "coreIdea": "维护已排序链表，逐个插入新节点。使用虚拟头节点，遍历原链表，为每个节点在已排序部分找到正确的插入位置。插入排序适合链表结构，避免了数组中的大量元素移动。",
    "codeSnippet": "function insertionSortList(head) {\n  const dummy = new ListNode(-Infinity);\n  let current = head;\n  \n  while (current) {\n    const next = current.next;\n    let prev = dummy;\n    \n    // 找到插入位置\n    while (prev.next && prev.next.val < current.val) {\n      prev = prev.next;\n    }\n    \n    // 插入节点\n    current.next = prev.next;\n    prev.next = current;\n    \n    current = next;\n  }\n  \n  return dummy.next;\n}",
    "difficulty": "medium",
    "type": ["排序", "遍历","转换"]
  },
  {
    "id": "removeElements",
    "title": "移除链表元素",
    "description": "删除链表中所有满足val等于给定值的节点",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "coreIdea": "使用虚拟头节点处理边界情况。遍历链表，当遇到目标值时跳过该节点，否则移动到下一个节点。虚拟头节点确保即使删除头节点也能正确处理。",
    "codeSnippet": "function removeElements(head, val) {\n  const dummy = new ListNode(0, head);\n  let prev = dummy, current = head;\n  \n  while (current) {\n    if (current.val === val) {\n      prev.next = current.next;\n    } else {\n      prev = current;\n    }\n    current = current.next;\n  }\n  \n  return dummy.next;\n}",
    "difficulty": "easy",
    "type": ["删除", "遍历"]
  },
  {
    "id": "pairSum",
    "title": "链表最大孪生和",
    "description": "求链表孪生节点（首尾对称节点）的最大和",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "coreIdea": "反转后半链表，双指针求和。使用快慢指针找到中点，反转后半部分链表，然后用双指针从两端向中间移动，计算每对孪生节点的和，找到最大值。",
    "codeSnippet": "function pairSum(head) {\n  // 找到中点\n  let slow = head, fast = head;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  \n  // 反转后半链表\n  let prev = null, current = slow;\n  while (current) {\n    const next = current.next;\n    current.next = prev;\n    prev = current;\n    current = next;\n  }\n  \n  // 计算孪生和\n  let maxSum = 0;\n  let left = head, right = prev;\n  while (right) {\n    maxSum = Math.max(maxSum, left.val + right.val);\n    left = left.next;\n    right = right.next;\n  }\n  \n  return maxSum;\n}",
    "difficulty": "medium",
    "type": ["查找", "转换", "快慢指针", "反转"]
  },
  {
    "id": "getDecimalValue",
    "title": "二进制链表转整数",
    "description": "将表示二进制数的链表转换为十进制整数",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "coreIdea": "位运算累加结果。遍历链表，每次将当前结果左移一位，然后与当前节点值进行或运算。这种方法模拟了二进制数的计算过程，高效且直观。",
    "codeSnippet": "function getDecimalValue(head) {\n  let num = 0;\n  while (head) {\n    num = (num << 1) | head.val;\n    head = head.next;\n  }\n  return num;\n}",
    "difficulty": "easy",
    "type": ["转换", "数学运算", "位运算"]
  },
  {
    "id": "numComponents",
    "title": "链表组件",
    "description": "统计链表中在给定数组中出现过的连续段数量",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(m)",
    "coreIdea": "使用集合存储数组元素，遍历链表计数。当遇到数组中的元素时，如果前一个元素不在数组中，则开始新的连续段。这种方法可以准确统计连续段的数量。",
    "codeSnippet": "function numComponents(head, nums) {\n  const set = new Set(nums);\n  let count = 0;\n  let connected = false;\n  \n  while (head) {\n    if (set.has(head.val)) {\n      if (!connected) {\n        count++;\n        connected = true;\n      }\n    } else {\n      connected = false;\n    }\n    head = head.next;\n  }\n  \n  return count;\n}",
    "difficulty": "medium",
    "type": ["统计", "遍历", "哈希表"]
  }
]
