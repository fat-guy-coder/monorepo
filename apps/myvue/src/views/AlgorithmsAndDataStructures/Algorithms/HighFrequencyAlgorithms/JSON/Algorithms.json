{
  "sort": {
    "name": "排序",
    "algorithms": [
      {
        "title": "快速排序",
        "difficulty": "medium",
        "description": "实现快速排序算法对数组进行排序。",
        "thought": "选择一个基准元素，将数组分为两部分：小于基准的元素和大于基准的元素，然后递归地对两部分进行排序。",
        "complexity": "平均O(n log n)，最坏O(n²)",
        "code": "function quickSort(arr: number[]): number[] {\n  if (arr.length <= 1) return arr;\n\n  const pivot = arr[Math.floor(arr.length / 2)];\n  const left: number[] = [];\n  const right: number[] = [];\n  const equal: number[] = [];\n\n  for (const num of arr) {\n    if (num < pivot) left.push(num);\n    else if (num > pivot) right.push(num);\n    else equal.push(num);\n  }\n\n  return [...quickSort(left), ...equal, ...quickSort(right)];\n}"
      },
      {
        "title": "归并排序",
        "difficulty": "medium",
        "description": "实现归并排序算法对数组进行排序。",
        "thought": "将数组分为两部分，分别对两部分进行排序，然后将两部分合并。",
        "complexity": "O(n log n)",
        "code": "function mergeSort(arr: number[]): number[] {\n  if (arr.length <= 1) return arr;\n\n  const mid = Math.floor(arr.length / 2);\n  const left = arr.slice(0, mid);\n  const right = arr.slice(mid);\n\n  return merge(mergeSort(left), mergeSort(right));\n}"
      },
      {
        "title": "堆排序",
        "difficulty": "medium",
        "description": "实现堆排序算法对数组进行排序。",
        "thought": "将数组视为一个完全二叉树，然后使用堆的性质进行排序。",
        "complexity": "O(n log n)",
        "code": "function heapSort(arr: number[]): number[] {\n  const n = arr.length;\n\n  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {\n    heapify(arr, n, i);\n  }\n\n  for (let i = n - 1; i > 0; i--) {\n    [arr[0], arr[i]] = [arr[i], arr[0]];\n    heapify(arr, i, 0);\n  }\n\n  return arr;\n}"
      },
      {
        "title": "计数排序",
        "difficulty": "medium",
        "description": "实现计数排序算法对数组进行排序。",
        "thought": "使用计数数组记录每个元素出现的次数，然后根据计数数组重新构建排序后的数组。",
        "complexity": "O(n + k)",
        "code": "function countingSort(arr: number[]): number[] {\n  const max = Math.max(...arr);\n  const min = Math.min(...arr);\n  const range = max - min + 1;\n  const count = new Array(range).fill(0);\n\n  for (const num of arr) {\n    count[num - min]++;\n  }\n\n  for (let i = 1; i < count.length; i++) {\n    count[i] += count[i - 1];\n  }\n\n  const result = new Array(arr.length);\n  for (let i = arr.length - 1; i >= 0; i--) {\n    result[count[arr[i] - min] - 1] = arr[i];\n    count[arr[i] - min]--;\n  }\n\n  return result;\n}"
      },
      {
        "title": "桶排序",
        "difficulty": "medium",
        "description": "实现桶排序算法对数组进行排序。",
        "thought": "将数组分为若干个桶，然后对每个桶进行排序，最后将桶中的元素合并。",
        "complexity": "O(n + k)",
        "code": "function bucketSort(arr: number[]): number[] {\n  const max = Math.max(...arr);\n  const min = Math.min(...arr);\n  const bucketSize = 10;\n  const bucketCount = Math.floor((max - min) / bucketSize) + 1;\n  const buckets: number[][] = new Array(bucketCount);\n\n  for (const num of arr) {\n    const index = Math.floor((num - min) / bucketSize);\n    if (!buckets[index]) buckets[index] = [];\n    buckets[index].push(num);\n  }\n\n  return buckets.reduce((acc, bucket) => {\n    return acc.concat(bucketSort(bucket));\n  }, []);\n}"
      },
      {
        "title": "基数排序",
        "difficulty": "medium",
        "description": "实现基数排序算法对数组进行排序。",
        "thought": "将数组分为若干个桶，然后对每个桶进行排序，最后将桶中的元素合并。",
        "complexity": "O(n + k)",
        "code": "function radixSort(arr: number[]): number[] {\n  const max = Math.max(...arr);\n  const digits = Math.floor(Math.log10(max)) + 1;\n\n  for (let i = 0; i < digits; i++) {\n    const buckets: number[][] = new Array(10);\n    for (const num of arr) {\n      const digit = Math.floor(num / Math.pow(10, i)) % 10;\n      if (!buckets[digit]) buckets[digit] = [];\n      buckets[digit].push(num);\n    }\n\n    arr = buckets.reduce((acc, bucket) => {\n      return acc.concat(bucket);\n    }, []);\n  }\n\n  return arr;\n}"
      }
    ]
  },
  "array": {
    "name": "数组",
    "algorithms": [
      {
        "title": "两数之和",
        "difficulty": "easy",
        "description": "给定一个整数数组和一个目标值，找出数组中和为目标值的两个整数，并返回它们的下标。",
        "thought": "使用哈希表存储访问过的元素及其索引，对于每个元素，检查目标值减去当前元素的差值是否在哈希表中。",
        "complexity": "O(n)",
        "code": "function twoSum(nums: number[], target: number): number[] {\n  const map = new Map<number, number>();\n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i];\n    if (map.has(complement)) {\n      return [map.get(complement)!, i];\n    }\n    map.set(nums[i], i);\n  }\n  return [];\n}"
      },
      {
        "title": "盛最多水的容器",
        "difficulty": "medium",
        "description": "给定一个非负整数数组，表示一系列垂直线的高度，找出两条线，使它们与x轴共同构成的容器可以容纳最多的水。",
        "thought": "使用双指针法，从数组两端开始向中间移动，每次移动高度较小的指针，并计算当前面积，更新最大面积。",
        "complexity": "O(n)",
        "code": "function maxArea(height: number[]): number {\n  let left = 0;\n  let right = height.length - 1;\n  let max = 0;\n\n  while (left < right) {\n    const area = Math.min(height[left], height[right]) * (right - left);\n    max = Math.max(max, area);\n\n    if (height[left] < height[right]) {\n      left++;\n    } else {\n      right--;\n    }\n  }\n\n  return max;\n}"
      },
      {
        "title": "三数之和",
        "difficulty": "medium",
        "description": "给定一个包含n个整数的数组，找出所有满足a + b + c = 0的三元组，且不包含重复三元组。",
        "thought": "先对数组排序，然后固定一个数，使用双指针在剩余数组中寻找两个数使三数之和为零。注意跳过重复元素。",
        "complexity": "O(n²)",
        "code": "function threeSum(nums: number[]): number[][] {\n  const result: number[][] = [];\n  nums.sort((a, b) => a - b);\n\n  for (let i = 0; i < nums.length - 2; i++) {\n    if (i > 0 && nums[i] === nums[i-1]) continue;\n\n    let left = i + 1;\n    let right = nums.length - 1;\n\n    while (left < right) {\n      const sum = nums[i] + nums[left] + nums[right];\n\n      if (sum === 0) {\n        result.push([nums[i], nums[left], nums[right]]);\n        while (left < right && nums[left] === nums[left+1]) left++;\n        while (left < right && nums[right] === nums[right-1]) right--;\n        left++;\n        right--;\n      } else if (sum < 0) {\n        left++;\n      } else {\n        right--;\n      }\n    }\n  }\n\n  return result;\n}"
      },
      {
        "title": "合并两个有序数组",
        "difficulty": "easy",
        "description": "给定两个有序数组，将它们合并为一个有序数组。",
        "thought": "使用双指针法，从两个数组末尾开始比较，将较大的元素插入到新数组的末尾。",
        "complexity": "O(m + n)",
        "code": "function merge(nums1: number[], m: number, nums2: number[], n: number): void {\n  let i = m - 1;\n  let j = n - 1;\n  let k = m + n - 1;\n\n  while (i >= 0 && j >= 0) {\n    if (nums1[i] > nums2[j]) {\n      nums1[k--] = nums1[i--];\n    } else {\n      nums1[k--] = nums2[j--];\n    }\n  }\n\n  while (j >= 0) {\n    nums1[k--] = nums2[j--];\n  }\n}"
      },
      {
        "title": "移动零",
        "difficulty": "easy",
        "description": "给定一个数组，将所有0移动到数组的末尾，同时保持非零元素的相对顺序。",
        "thought": "使用双指针法，一个指针指向当前非零元素的位置，另一个指针遍历数组。当遇到非零元素时，将它与当前非零元素位置交换。",
        "complexity": "O(n)",
        "code": "function moveZeroes(nums: number[]): void {\n  let i = 0;\n  for (let j = 0; j < nums.length; j++) {\n    if (nums[j] !== 0) {\n      [nums[i], nums[j]] = [nums[j], nums[i]];\n      i++;\n    }\n  }\n}"
      },
      {
        "title": "删除排序数组中的重复项",
        "difficulty": "easy",
        "description": "给定一个排序数组，删除重复的元素，使得每个元素只出现一次，并返回新的长度。",
        "thought": "使用双指针法，一个指针指向当前非重复元素的位置，另一个指针遍历数组。当遇到非重复元素时，将它与当前非重复元素位置交换。",
        "complexity": "O(n)",
        "code": "function removeDuplicates(nums: number[]): number {\n  let i = 0;\n  for (let j = 1; j < nums.length; j++) {\n    if (nums[j] !== nums[i]) {\n      i++;\n      nums[i] = nums[j];\n    }\n  }\n  return i + 1;\n}"
      }
    ]
  },
  "linkedList": {
    "name": "链表",
    "algorithms": [
      {
        "title": "反转链表",
        "difficulty": "easy",
        "description": "反转一个单链表。",
        "thought": "使用三个指针：prev、current和next。遍历链表，将当前节点的next指向prev，然后移动所有指针。",
        "complexity": "O(n)",
        "code": "class ListNode {\n  val: number;\n  next: ListNode | null;\n  constructor(val?: number, next?: ListNode | null) {\n    this.val = (val === undefined ? 0 : val);\n    this.next = (next === undefined ? null : next);\n  }\n}\n\nfunction reverseList(head: ListNode | null): ListNode | null {\n  let prev = null;\n  let current = head;\n\n  while (current !== null) {\n    const next = current.next;\n    current.next = prev;\n    prev = current;\n    current = next;\n  }\n\n  return prev;\n}"
      },
      {
        "title": "环形链表检测",
        "difficulty": "easy",
        "description": "给定一个链表，判断链表中是否有环。",
        "thought": "使用快慢指针，快指针每次走两步，慢指针每次走一步。如果存在环，快慢指针最终会相遇。",
        "complexity": "O(n)",
        "code": "function hasCycle(head: ListNode | null): boolean {\n  if (!head || !head.next) return false;\n\n  let slow = head;\n  let fast = head.next;\n\n  while (slow !== fast) {\n    if (!fast || !fast.next) return false;\n    slow = slow.next!;\n    fast = fast.next.next!;\n  }\n\n  return true;\n}"
      }
    ]
  },
  "tree": {
    "name": "树",
    "algorithms": [
      {
        "title": "二叉树的中序遍历",
        "difficulty": "easy",
        "description": "给定一个二叉树的根节点，返回它的中序遍历。",
        "thought": "使用递归或迭代方法（使用栈）实现中序遍历：左子树 -> 根节点 -> 右子树。",
        "complexity": "O(n)",
        "code": "class TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n    this.val = (val === undefined ? 0 : val);\n    this.left = (left === undefined ? null : left);\n    this.right = (right === undefined ? null : right);\n  }\n}\n\n// 递归实现\nfunction inorderTraversal(root: TreeNode | null): number[] {\n  const result: number[] = [];\n\n  function traverse(node: TreeNode | null) {\n    if (!node) return;\n    traverse(node.left);\n    result.push(node.val);\n    traverse(node.right);\n  }\n\n  traverse(root);\n  return result;\n}\n\n// 迭代实现\nfunction inorderTraversalIterative(root: TreeNode | null): number[] {\n  const result: number[] = [];\n  const stack: TreeNode[] = [];\n  let current = root;\n\n  while (current || stack.length) {\n    while (current) {\n      stack.push(current);\n      current = current.left;\n    }\n\n    current = stack.pop()!;\n    result.push(current.val);\n    current = current.right;\n  }\n\n  return result;\n}"
      },
      {
        "title": "二叉树的层序遍历",
        "difficulty": "medium",
        "description": "给定一个二叉树，返回其节点值的层序遍历（即逐层地，从左到右访问所有节点）。",
        "thought": "使用队列实现广度优先搜索。每次处理一层节点，并将下一层节点加入队列。",
        "complexity": "O(n)",
        "code": "function levelOrder(root: TreeNode | null): number[][] {\n  if (!root) return [];\n\n  const result: number[][] = [];\n  const queue: TreeNode[] = [root];\n\n  while (queue.length) {\n    const levelSize = queue.length;\n    const currentLevel: number[] = [];\n\n    for (let i = 0; i < levelSize; i++) {\n      const node = queue.shift()!;\n      currentLevel.push(node.val);\n\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n\n    result.push(currentLevel);\n  }\n\n  return result;\n}"
      }
    ]
  },
  "greedy": {
    "name": "贪心",
    "algorithms": [
      {
        "title": "跳跃游戏",
        "difficulty": "medium",
        "description": "给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。",
        "thought": "使用贪心算法，每次选择能跳跃到最远的点作为下一步。",
        "complexity": "O(n)",
        "code": "function canJump(nums: number[]): boolean {\n  let maxReach = 0;\n\n  for (let i = 0; i < nums.length; i++) {\n    if (i > maxReach) return false;\n    maxReach = Math.max(maxReach, i + nums[i]);\n  }\n\n  return true;\n}"
      }
    ]
  },
  "dynamicProgramming": {
    "name": "动态规划",
    "algorithms": [
      {
        "title": "爬楼梯",
        "difficulty": "easy",
        "description": "你正在爬楼梯，需要n阶才能到达楼顶。每次你可以爬1或2个台阶。有多少种不同的方法可以爬到楼顶？",
        "thought": "动态规划：到达第n阶的方法数等于到达第n-1阶和第n-2阶的方法数之和。可以使用滚动数组优化空间复杂度。",
        "complexity": "O(n)",
        "code": "function climbStairs(n: number): number {\n  if (n <= 2) return n;\n\n  let a = 1, b = 2;\n  for (let i = 3; i <= n; i++) {\n    [a, b] = [b, a + b];\n  }\n\n  return b;\n}"
      },
      {
        "title": "最长递增子序列",
        "difficulty": "medium",
        "description": "给定一个整数数组，找到其中最长严格递增子序列的长度。",
        "thought": "动态规划：dp[i]表示以nums[i]结尾的最长递增子序列长度。使用二分查找优化到O(n log n)。",
        "complexity": "O(n log n)",
        "code": "function lengthOfLIS(nums: number[]): number {\n  const tails: number[] = [];\n\n  for (const num of nums) {\n    let left = 0;\n    let right = tails.length;\n\n    while (left < right) {\n      const mid = Math.floor((left + right) / 2);\n      if (tails[mid] < num) {\n        left = mid + 1;\n      } else {\n        right = mid;\n      }\n    }\n\n    if (left === tails.length) {\n      tails.push(num);\n    } else {\n      tails[left] = num;\n    }\n  }\n\n  return tails.length;\n}"
      }
    ]
  },
  "search": {
    "name": "查找",
    "algorithms": [
      {
        "title": "二分查找",
        "difficulty": "easy",
        "description": "给定一个升序排列的整数数组和一个目标值，如果目标值存在于数组中，则返回其索引，否则返回-1。",
        "thought": "使用二分查找算法：每次将搜索范围缩小一半，直到找到目标值或搜索范围为空。",
        "complexity": "O(log n)",
        "code": "function search(nums: number[], target: number): number {\n  let left = 0;\n  let right = nums.length - 1;\n\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n\n    if (nums[mid] === target) {\n      return mid;\n    } else if (nums[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n\n  return -1;\n}"
      }
    ]
  },
  "other": {
    "name": "其他",
    "algorithms": [
      {
        "title": "位运算",
        "difficulty": "easy",
        "description": "给定一个整数，返回其二进制表示中1的个数。",
        "thought": "使用位运算：将整数与1进行与运算，如果结果为1，则说明该位是1，否则是0。",
        "complexity": "O(1)",
        "code": "function hammingWeight(n: number): number {\n  let count = 0;\n  while (n !== 0) {\n    count += n & 1;\n    n >>>= 1;\n  }\n  return count;\n}"
      }
    ]
  }
}
