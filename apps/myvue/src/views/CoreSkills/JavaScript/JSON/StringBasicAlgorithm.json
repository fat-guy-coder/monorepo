[
  {
    "id": "reverse",
    "title": "å­—ç¬¦ä¸²åè½¬",
    "description": "å°†å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦é¡ºåºå®Œå…¨åè½¬",
    "difficulty": "easy",
    "type": ["å˜æ¢"],
    "icon": "ğŸ”",
    "steps": [
      "å°†å­—ç¬¦ä¸²æ‹†åˆ†ä¸ºå­—ç¬¦æ•°ç»„",
      "ä½¿ç”¨æ•°ç»„çš„reverse()æ–¹æ³•åè½¬æ•°ç»„",
      "å°†åè½¬åçš„æ•°ç»„é‡æ–°è¿æ¥æˆå­—ç¬¦ä¸²"
    ],
    "solution": [
      {
        "index": 1,
        "title": "ä½¿ç”¨æ•°ç»„çš„reverse()ç»“åˆæ–¹æ³•åè½¬æ•°ç»„",
        "description": "ä½¿ç”¨æ•°ç»„çš„reverse()ç»“åˆæ–¹æ³•åè½¬æ•°ç»„",
        "code": "function reverseString(str: string): string {\n    return str.split('').reverse().join('');\n}",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "tips": "ä½¿ç”¨...å±•å¼€å­—ç¬¦ä¸²ï¼Œå°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•°ç»„ï¼Œç„¶åä½¿ç”¨æ•°ç»„çš„reverse()æ–¹æ³•åè½¬æ•°ç»„ï¼Œæœ€åå°†åè½¬åçš„æ•°ç»„é‡æ–°è¿æ¥æˆå­—ç¬¦ä¸²"
      },
      {
        "index": 2,
        "title": "ä½¿ç”¨åŒæŒ‡é’ˆæ³•åè½¬å­—ç¬¦ä¸²",
        "description": "ä½¿ç”¨åŒæŒ‡é’ˆæ³•åè½¬å­—ç¬¦ä¸²ï¼Œä¸€ä¸ªæŒ‡é’ˆä»å¤´éƒ¨å¼€å§‹ï¼Œä¸€ä¸ªæŒ‡é’ˆä»å°¾éƒ¨å¼€å§‹ï¼Œäº¤æ¢ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘çš„å­—ç¬¦ï¼Œç›´åˆ°ä¸¤ä¸ªæŒ‡é’ˆç›¸é‡",
        "code": "function reverseString(str: string): string {\n    let left = 0;\n    let right = str.length - 1;\n    let arr = str.split('');\n    while (left < right) {\n        [arr[left], arr[right]] = [arr[right], arr[left]];\n        left++;\n        right--;\n    }\n    return arr.join('');\n}",
        "timeComplexity": "O(logn)",
        "spaceComplexity": "O(1)"
      },
      {
        "index": 3,
        "title": "ä½¿ç”¨é€’å½’æ³•åè½¬å­—ç¬¦ä¸²",
        "description": "ä½¿ç”¨é€’å½’æ³•åè½¬å­—ç¬¦ä¸²ï¼Œå¦‚æœå­—ç¬¦ä¸²é•¿åº¦å°äºç­‰äº1ï¼Œåˆ™ç›´æ¥è¿”å›å­—ç¬¦ä¸²ï¼Œå¦åˆ™å°†å­—ç¬¦ä¸²çš„ç¬¬ä¸€ä¸ªå­—ç¬¦å’Œå‰©ä½™å­—ç¬¦ä¸²é€’å½’åè½¬",
        "code": "function reverseString(str: string): string {\n    if (str.length <= 1) return str;\n    return reverseString(str.slice(1)) + str[0];\n}",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      {
        "index": 4,
        "title": "ä½¿ç”¨æ ˆåè½¬å­—ç¬¦ä¸²",
        "description": "ä½¿ç”¨æ ˆåè½¬å­—ç¬¦ä¸²ï¼Œå°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•°ç»„ï¼Œç„¶åä½¿ç”¨æ•°ç»„çš„reverse()æ–¹æ³•åè½¬æ•°ç»„ï¼Œæœ€åå°†åè½¬åçš„æ•°ç»„é‡æ–°è¿æ¥æˆå­—ç¬¦ä¸²",
        "code": "function reverseString(str: string): string {\n    const stack = [];\n    for (let i = 0; i < str.length; i++) {\n        stack.push(str[i]);\n    }\n    return stack.reverse().join('');\n}",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ],
    "code": "function reverseString(str: string): string {\n    return str.split('').reverse().join('');\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)"
  },
  {
    "id": "palindrome",
    "title": "å›æ–‡æ£€æµ‹",
    "description": "åˆ¤æ–­ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦æ­£åºå’Œå€’åºç›¸åŒ",
    "difficulty": "easy",
    "type": ["ç»Ÿè®¡"],
    "icon": "ğŸ”„",
    "steps": [
      "æ¸…ç†å­—ç¬¦ä¸²ï¼ˆç§»é™¤éå­—æ¯æ•°å­—å­—ç¬¦å¹¶è½¬ä¸ºå°å†™ï¼‰",
      "ä½¿ç”¨åŒæŒ‡é’ˆæ³•ï¼Œä¸€ä¸ªä»å¤´éƒ¨å¼€å§‹ï¼Œä¸€ä¸ªä»å°¾éƒ¨å¼€å§‹",
      "æ¯”è¾ƒä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘çš„å­—ç¬¦æ˜¯å¦ç›¸åŒ",
      "å¦‚æœæ‰€æœ‰å­—ç¬¦éƒ½åŒ¹é…ï¼Œåˆ™æ˜¯å›æ–‡"
    ],
    "code": "function isPalindrome(str: string): boolean {\n    const cleanStr = str.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();\n    let left = 0;\n    let right = cleanStr.length - 1;\n\n    while (left < right) {\n        if (cleanStr[left] !== cleanStr[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)"
  },
  {
    "id": "vowel-count",
    "title": "å…ƒéŸ³å­—æ¯è®¡æ•°",
    "description": "è®¡ç®—å­—ç¬¦ä¸²ä¸­å…ƒéŸ³å­—æ¯(a, e, i, o, u)çš„æ•°é‡",
    "difficulty": "easy",
    "type": ["ç»Ÿè®¡"],
    "icon": "ğŸ”¤",
    "steps": [
      "å®šä¹‰ä¸€ä¸ªåŒ…å«æ‰€æœ‰å…ƒéŸ³å­—æ¯çš„é›†åˆ",
      "åˆå§‹åŒ–è®¡æ•°å™¨ä¸º0",
      "éå†å­—ç¬¦ä¸²ä¸­çš„æ¯ä¸ªå­—ç¬¦",
      "å¦‚æœå­—ç¬¦æ˜¯å…ƒéŸ³å­—æ¯ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰ï¼Œåˆ™è®¡æ•°å™¨åŠ 1"
    ],
    "code": "function countVowels(str: string): number {\n    const vowels = new Set(['a', 'e', 'i', 'o', 'u']);\n    let count = 0;\n\n    for (const char of str.toLowerCase()) {\n        if (vowels.has(char)) {\n            count++;\n        }\n    }\n    return count;\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)"
  },
  {
    "id": "anagram",
    "title": "å˜ä½è¯æ£€æµ‹",
    "description": "åˆ¤æ–­ä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦åŒ…å«ç›¸åŒçš„å­—ç¬¦å¹¶ä¸”æ•°é‡ç›¸åŒï¼ˆä¸è€ƒè™‘é¡ºåºï¼‰",
    "difficulty": "easy",
    "type": ["æŸ¥æ‰¾", "ç»Ÿè®¡"],
    "icon": "ğŸ§©",
    "steps": [
      "å¦‚æœä¸¤ä¸ªå­—ç¬¦ä¸²é•¿åº¦ä¸åŒï¼Œç›´æ¥è¿”å›false",
      "åˆ›å»ºä¸€ä¸ªå­—ç¬¦è®¡æ•°å­—å…¸",
      "éå†ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œç»Ÿè®¡æ¯ä¸ªå­—ç¬¦å‡ºç°çš„æ¬¡æ•°",
      "éå†ç¬¬äºŒä¸ªå­—ç¬¦ä¸²ï¼Œå‡å°‘è®¡æ•°å™¨ä¸­å¯¹åº”å­—ç¬¦çš„è®¡æ•°",
      "å¦‚æœæ‰€æœ‰è®¡æ•°éƒ½å˜ä¸º0ï¼Œåˆ™æ˜¯å˜ä½è¯"
    ],
    "code": "function areAnagrams(str1: string, str2: string): boolean {\n    if (str1.length !== str2.length) return false;\n\n    const charCount: Record<string, number> = {};\n\n    for (const char of str1) {\n        charCount[char] = (charCount[char] || 0) + 1;\n    }\n\n    for (const char of str2) {\n        if (!charCount[char]) return false;\n        charCount[char]--;\n    }\n\n    return Object.values(charCount).every(count => count === 0);\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)"
  },
  {
    "id": "capitalize",
    "title": "é¦–å­—æ¯å¤§å†™",
    "description": "å°†å­—ç¬¦ä¸²ä¸­æ¯ä¸ªå•è¯çš„é¦–å­—æ¯è½¬ä¸ºå¤§å†™",
    "difficulty": "easy",
    "type": ["å˜æ¢", "æŸ¥æ‰¾"],
    "icon": "âœ¨",
    "steps": [
      "å°†å­—ç¬¦ä¸²æ‹†åˆ†ä¸ºå•è¯æ•°ç»„",
      "éå†æ¯ä¸ªå•è¯",
      "å°†æ¯ä¸ªå•è¯çš„é¦–å­—æ¯è½¬ä¸ºå¤§å†™ï¼Œå…¶ä½™å­—æ¯è½¬ä¸ºå°å†™",
      "å°†å¤„ç†åçš„å•è¯é‡æ–°è¿æ¥æˆå­—ç¬¦ä¸²"
    ],
    "code": "function capitalizeWords(str: string): string {\n    return str\n        .split(' ')\n        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n        .join(' ');\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "longestWord",
    "title": "æœ€é•¿å•è¯",
    "description": "æ‰¾å‡ºå­—ç¬¦ä¸²ä¸­æœ€é•¿çš„å•è¯",
    "difficulty": "easy",
    "type": ["ç»Ÿè®¡"],
    "icon": "ğŸ“",
    "steps": [
      "ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æˆ–ç©ºæ ¼æ‹†åˆ†å­—ç¬¦ä¸²ä¸ºå•è¯æ•°ç»„",
      "åˆå§‹åŒ–æœ€é•¿å•è¯ä¸ºç©ºå­—ç¬¦ä¸²",
      "éå†æ‰€æœ‰å•è¯",
      "æ¯”è¾ƒæ¯ä¸ªå•è¯çš„é•¿åº¦ï¼Œä¿ç•™æœ€é•¿çš„å•è¯"
    ],
    "code": "function findLongestWord(str: string): string {\n    const words = str.split(/\\s+/);\n    let longestWord = '';\n\n    for (const word of words) {\n        if (word.length > longestWord.length) {\n            longestWord = word;\n        }\n    }\n\n    return longestWord;\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "truncate",
    "title": "å­—ç¬¦ä¸²æˆªæ–­",
    "description": "åœ¨æŒ‡å®šé•¿åº¦å¤„æˆªæ–­å­—ç¬¦ä¸²ï¼Œå¹¶æ·»åŠ çœç•¥å·",
    "difficulty": "easy",
    "type": ["æŸ¥æ‰¾", "æˆªå–"],
    "icon": "âœ‚ï¸",
    "steps": [
      "æ£€æŸ¥å­—ç¬¦ä¸²é•¿åº¦æ˜¯å¦è¶…è¿‡æœ€å¤§é•¿åº¦",
      "å¦‚æœæœªè¶…è¿‡ï¼Œç›´æ¥è¿”å›åŸå­—ç¬¦ä¸²",
      "å¦‚æœè¶…è¿‡ï¼Œæˆªå–åˆ°æœ€å¤§é•¿åº¦å‡3çš„ä½ç½®",
      "åœ¨æœ«å°¾æ·»åŠ çœç•¥å·"
    ],
    "code": "function truncateString(str: string, maxLength: number): string {\n    if (str.length <= maxLength) return str;\n    return str.slice(0, maxLength - 3) + '...';\n}",
    "timeComplexity": "O(1)",
    "spaceComplexity": "O(1)"
  },
  {
    "id": "charCount",
    "title": "å­—ç¬¦å‡ºç°æ¬¡æ•°",
    "description": "è®¡ç®—ç‰¹å®šå­—ç¬¦åœ¨å­—ç¬¦ä¸²ä¸­å‡ºç°çš„æ¬¡æ•°",
    "difficulty": "easy",
    "type": ["æŸ¥æ‰¾", "ç»Ÿè®¡"],
    "icon": "ğŸ”¢",
    "steps": [
      "åˆå§‹åŒ–è®¡æ•°å™¨ä¸º0",
      "éå†å­—ç¬¦ä¸²ä¸­çš„æ¯ä¸ªå­—ç¬¦",
      "å¦‚æœå­—ç¬¦åŒ¹é…ç›®æ ‡å­—ç¬¦ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰ï¼Œè®¡æ•°å™¨åŠ 1",
      "è¿”å›è®¡æ•°ç»“æœ"
    ],
    "code": "function countCharOccurrences(str: string, char: string): number {\n    const targetChar = char.toLowerCase();\n    let count = 0;\n\n    for (const c of str.toLowerCase()) {\n        if (c === targetChar) {\n            count++;\n        }\n    }\n\n    return count;\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)"
  },
  {
    "id": "removeDuplicates",
    "title": "å»é™¤é‡å¤å­—ç¬¦",
    "description": "ç§»é™¤å­—ç¬¦ä¸²ä¸­çš„é‡å¤å­—ç¬¦ï¼Œä¿æŒåŸæœ‰é¡ºåº",
    "difficulty": "easy",
    "type": ["æŸ¥æ‰¾", "æˆªå–"],
    "icon": "ğŸ§¹",
    "steps": [
      "åˆ›å»ºä¸€ä¸ªSetæ¥è·Ÿè¸ªå·²è§è¿‡çš„å­—ç¬¦",
      "åˆ›å»ºä¸€ä¸ªç»“æœå­—ç¬¦ä¸²",
      "éå†åŸå­—ç¬¦ä¸²çš„æ¯ä¸ªå­—ç¬¦",
      "å¦‚æœå­—ç¬¦æœªè§è¿‡ï¼Œæ·»åŠ åˆ°ç»“æœä¸­å¹¶è®°å½•åˆ°Setä¸­",
      "è¿”å›å»é‡åçš„å­—ç¬¦ä¸²"
    ],
    "code": "function removeDuplicates(str: string): string {\n    const seen = new Set<string>();\n    let result = '';\n\n    for (const char of str) {\n        if (!seen.has(char)) {\n            seen.add(char);\n            result += char;\n        }\n    }\n\n    return result;\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "stringRotation",
    "title": "å­—ç¬¦ä¸²æ—‹è½¬",
    "description": "åˆ¤æ–­ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦å¯ä»¥é€šè¿‡æ—‹è½¬å¦ä¸€ä¸ªå­—ç¬¦ä¸²å¾—åˆ°",
    "difficulty": "easy",
    "type": ["æŸ¥æ‰¾", "ç»Ÿè®¡"],
    "icon": "ğŸ”„",
    "steps": [
      "æ£€æŸ¥ä¸¤ä¸ªå­—ç¬¦ä¸²é•¿åº¦æ˜¯å¦ç›¸ç­‰",
      "å°†ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ä¸è‡ªèº«è¿æ¥",
      "æ£€æŸ¥ç¬¬äºŒä¸ªå­—ç¬¦ä¸²æ˜¯å¦æ˜¯è¿æ¥åå­—ç¬¦ä¸²çš„å­ä¸²",
      "å¦‚æœæ˜¯ï¼Œåˆ™å¯ä»¥é€šè¿‡æ—‹è½¬å¾—åˆ°"
    ],
    "code": "function isRotation(str1: string, str2: string): boolean {\n    if (str1.length !== str2.length) return false;\n    const concatenated = str1 + str1;\n    return concatenated.includes(str2);\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "firstNonRepeating",
    "title": "ç¬¬ä¸€ä¸ªéé‡å¤å­—ç¬¦",
    "description": "æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­ç¬¬ä¸€ä¸ªåªå‡ºç°ä¸€æ¬¡çš„å­—ç¬¦",
    "difficulty": "easy",
    "type": ["æŸ¥æ‰¾", "ç»Ÿè®¡"],
    "icon": "ğŸ”",
    "steps": [
      "åˆ›å»ºä¸€ä¸ªMapæ¥ç»Ÿè®¡æ¯ä¸ªå­—ç¬¦çš„å‡ºç°æ¬¡æ•°",
      "ç¬¬ä¸€æ¬¡éå†ï¼šç»Ÿè®¡æ‰€æœ‰å­—ç¬¦çš„å‡ºç°æ¬¡æ•°",
      "ç¬¬äºŒæ¬¡éå†ï¼šæ‰¾åˆ°ç¬¬ä¸€ä¸ªè®¡æ•°ä¸º1çš„å­—ç¬¦",
      "å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œè¿”å›ç©ºå­—ç¬¦ä¸²"
    ],
    "code": "function firstNonRepeatingChar(str: string): string {\n    const charCount = new Map<string, number>();\n\n    for (const char of str) {\n        charCount.set(char, (charCount.get(char) || 0) + 1);\n    }\n\n    for (const char of str) {\n        if (charCount.get(char) === 1) {\n            return char;\n        }\n    }\n\n    return '';\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "stringCompression",
    "title": "å­—ç¬¦ä¸²å‹ç¼©",
    "description": "å°†è¿ç»­é‡å¤å­—ç¬¦å‹ç¼©ä¸ºå­—ç¬¦+æ¬¡æ•°çš„æ ¼å¼",
    "difficulty": "easy",
    "type": ["å˜æ¢", "ç»Ÿè®¡"],
    "icon": "ğŸ—œï¸",
    "steps": [
      "åˆå§‹åŒ–ç»“æœå­—ç¬¦ä¸²å’Œè®¡æ•°å™¨",
      "éå†å­—ç¬¦ä¸²ï¼Œæ¯”è¾ƒå½“å‰å­—ç¬¦ä¸å‰ä¸€ä¸ªå­—ç¬¦",
      "å¦‚æœç›¸åŒï¼Œè®¡æ•°å™¨åŠ 1",
      "å¦‚æœä¸åŒï¼Œå°†å‰ä¸€ä¸ªå­—ç¬¦å’Œè®¡æ•°æ·»åŠ åˆ°ç»“æœä¸­",
      "å¤„ç†æœ€åä¸€ä¸ªå­—ç¬¦ç»„"
    ],
    "code": "function compressString(str: string): string {\n    if (str.length === 0) return str;\n\n    let result = '';\n    let count = 1;\n    let currentChar = str[0];\n\n    for (let i = 1; i < str.length; i++) {\n        if (str[i] === currentChar) {\n            count++;\n        } else {\n            result += currentChar + (count > 1 ? count : '');\n            currentChar = str[i];\n            count = 1;\n        }\n    }\n\n    result += currentChar + (count > 1 ? count : '');\n    return result;\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "validParentheses",
    "title": "æœ‰æ•ˆæ‹¬å·",
    "description": "åˆ¤æ–­å­—ç¬¦ä¸²ä¸­çš„æ‹¬å·æ˜¯å¦æœ‰æ•ˆåŒ¹é…",
    "difficulty": "easy",
    "type": ["æŸ¥æ‰¾", "ç»Ÿè®¡"],
    "icon": "ğŸ“",
    "steps": [
      "åˆ›å»ºä¸€ä¸ªæ ˆæ¥å­˜å‚¨å·¦æ‹¬å·",
      "éå†å­—ç¬¦ä¸²ä¸­çš„æ¯ä¸ªå­—ç¬¦",
      "å¦‚æœæ˜¯å·¦æ‹¬å·ï¼Œå‹å…¥æ ˆä¸­",
      "å¦‚æœæ˜¯å³æ‹¬å·ï¼Œæ£€æŸ¥æ ˆé¡¶æ˜¯å¦åŒ¹é…",
      "æœ€åæ£€æŸ¥æ ˆæ˜¯å¦ä¸ºç©º"
    ],
    "code": "function isValidParentheses(str: string): boolean {\n    const stack: string[] = [];\n    const pairs: Record<string, string> = {\n        ')': '(',\n        '}': '{',\n        ']': '['\n    };\n\n    for (const char of str) {\n        if (pairs[char]) {\n            if (stack.pop() !== pairs[char]) {\n                return false;\n            }\n        } else {\n            stack.push(char);\n        }\n    }\n\n    return stack.length === 0;\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "longestCommonPrefix",
    "title": "æœ€é•¿å…¬å…±å‰ç¼€",
    "description": "æ‰¾åˆ°å­—ç¬¦ä¸²æ•°ç»„ä¸­æœ€é•¿çš„å…¬å…±å‰ç¼€",
    "difficulty": "easy",
    "type": ["æŸ¥æ‰¾"],
    "icon": "ğŸ”—",
    "steps": [
      "å¦‚æœæ•°ç»„ä¸ºç©ºï¼Œè¿”å›ç©ºå­—ç¬¦ä¸²",
      "ä»¥ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ä¸ºåŸºå‡†",
      "éå†ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²çš„æ¯ä¸ªå­—ç¬¦ä½ç½®",
      "æ£€æŸ¥å…¶ä»–å­—ç¬¦ä¸²åœ¨ç›¸åŒä½ç½®æ˜¯å¦åŒ¹é…",
      "è¿”å›åŒ¹é…çš„æœ€é•¿å‰ç¼€"
    ],
    "code": "function longestCommonPrefix(strs: string[]): string {\n    if (strs.length === 0) return '';\n    if (strs.length === 1) return strs[0];\n\n    let prefix = '';\n    const firstStr = strs[0];\n\n    for (let i = 0; i < firstStr.length; i++) {\n        const char = firstStr[i];\n        for (let j = 1; j < strs.length; j++) {\n            if (i >= strs[j].length || strs[j][i] !== char) {\n                return prefix;\n            }\n        }\n        prefix += char;\n    }\n\n    return prefix;\n}",
    "timeComplexity": "O(S)",
    "spaceComplexity": "O(1)"
  },
  {
    "id": "wordFrequency",
    "title": "å•è¯é¢‘ç‡ç»Ÿè®¡",
    "description": "ç»Ÿè®¡å­—ç¬¦ä¸²ä¸­æ¯ä¸ªå•è¯å‡ºç°çš„æ¬¡æ•°",
    "difficulty": "easy",
    "type": ["ç»Ÿè®¡"],
    "icon": "ğŸ“Š",
    "steps": [
      "æ¸…ç†å­—ç¬¦ä¸²ï¼Œç§»é™¤éå­—æ¯å­—ç¬¦",
      "å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºå°å†™å¹¶æ‹†åˆ†ä¸ºå•è¯",
      "åˆ›å»ºä¸€ä¸ªMapæ¥ç»Ÿè®¡å•è¯é¢‘ç‡",
      "éå†å•è¯æ•°ç»„ï¼Œæ›´æ–°è®¡æ•°",
      "è¿”å›å•è¯é¢‘ç‡æ˜ å°„"
    ],
    "code": "function getWordFrequency(str: string): Map<string, number> {\n    const cleanStr = str.replace(/[^a-zA-Z\\s]/g, '').toLowerCase();\n    const words = cleanStr.split(/\\s+/).filter(word => word.length > 0);\n    const frequency = new Map<string, number>();\n\n    for (const word of words) {\n        frequency.set(word, (frequency.get(word) || 0) + 1);\n    }\n\n    return frequency;\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "stringPermutation",
    "title": "å­—ç¬¦ä¸²æ’åˆ—",
    "description": "ç”Ÿæˆå­—ç¬¦ä¸²çš„æ‰€æœ‰å¯èƒ½æ’åˆ—",
    "difficulty": "medium",
    "type": ["ç»Ÿè®¡"],
    "icon": "ğŸ²",
    "steps": [
      "ä½¿ç”¨é€’å½’æ–¹æ³•ç”Ÿæˆæ’åˆ—",
      "å¦‚æœå­—ç¬¦ä¸²é•¿åº¦ä¸º1ï¼Œè¿”å›è¯¥å­—ç¬¦",
      "å¯¹äºæ¯ä¸ªå­—ç¬¦ï¼Œå°†å…¶ä½œä¸ºç¬¬ä¸€ä¸ªå­—ç¬¦",
      "é€’å½’ç”Ÿæˆå‰©ä½™å­—ç¬¦çš„æ’åˆ—",
      "åˆå¹¶æ‰€æœ‰æ’åˆ—ç»“æœ"
    ],
    "code": "function generatePermutations(str: string): string[] {\n    if (str.length <= 1) return [str];\n\n    const permutations: string[] = [];\n\n    for (let i = 0; i < str.length; i++) {\n        const char = str[i];\n        const remaining = str.slice(0, i) + str.slice(i + 1);\n        const subPermutations = generatePermutations(remaining);\n\n        for (const perm of subPermutations) {\n            permutations.push(char + perm);\n        }\n    }\n\n    return permutations;\n}",
    "timeComplexity": "O(n!)",
    "spaceComplexity": "O(n!)"
  },
  {
    "id": "stringEncoding",
    "title": "å­—ç¬¦ä¸²ç¼–ç ",
    "description": "å°†å­—ç¬¦ä¸²ç¼–ç ä¸ºå­—ç¬¦+é‡å¤æ¬¡æ•°çš„æ ¼å¼",
    "difficulty": "easy",
    "type": ["å˜æ¢", "ç»Ÿè®¡"],
    "icon": "ğŸ”",
    "steps": [
      "åˆå§‹åŒ–ç»“æœå­—ç¬¦ä¸²å’Œè®¡æ•°å™¨",
      "éå†å­—ç¬¦ä¸²ï¼Œç»Ÿè®¡è¿ç»­ç›¸åŒå­—ç¬¦",
      "å½“å­—ç¬¦æ”¹å˜æ—¶ï¼Œå°†å‰ä¸€ä¸ªå­—ç¬¦å’Œè®¡æ•°æ·»åŠ åˆ°ç»“æœ",
      "å¤„ç†æœ€åä¸€ä¸ªå­—ç¬¦ç»„",
      "è¿”å›ç¼–ç åçš„å­—ç¬¦ä¸²"
    ],
    "code": "function encodeString(str: string): string {\n    if (str.length === 0) return str;\n\n    let result = '';\n    let count = 1;\n    let currentChar = str[0];\n\n    for (let i = 1; i < str.length; i++) {\n        if (str[i] === currentChar) {\n            count++;\n        } else {\n            result += currentChar + count;\n            currentChar = str[i];\n            count = 1;\n        }\n    }\n\n    result += currentChar + count;\n    return result;\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "stringDecoding",
    "title": "å­—ç¬¦ä¸²è§£ç ",
    "description": "å°†ç¼–ç åçš„å­—ç¬¦ä¸²è§£ç ä¸ºåŸå§‹å­—ç¬¦ä¸²",
    "difficulty": "easy",
    "type": ["å˜æ¢", "ç»Ÿè®¡"],
    "icon": "ğŸ”“",
    "steps": [
      "åˆå§‹åŒ–ç»“æœå­—ç¬¦ä¸²",
      "éå†ç¼–ç å­—ç¬¦ä¸²ï¼Œæå–å­—ç¬¦å’Œæ•°å­—",
      "å°†å­—ç¬¦é‡å¤æŒ‡å®šæ¬¡æ•°",
      "æ·»åŠ åˆ°ç»“æœå­—ç¬¦ä¸²ä¸­",
      "è¿”å›è§£ç åçš„å­—ç¬¦ä¸²"
    ],
    "code": "function decodeString(str: string): string {\n    let result = '';\n    let i = 0;\n\n    while (i < str.length) {\n        const char = str[i];\n        i++;\n        let count = '';\n\n        while (i < str.length && /\\d/.test(str[i])) {\n            count += str[i];\n            i++;\n        }\n\n        const repeatCount = parseInt(count) || 1;\n        result += char.repeat(repeatCount);\n    }\n\n    return result;\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "stringDifference",
    "title": "å­—ç¬¦ä¸²å·®å¼‚",
    "description": "æ‰¾åˆ°ä¸¤ä¸ªå­—ç¬¦ä¸²çš„ç¬¬ä¸€ä¸ªä¸åŒå­—ç¬¦ä½ç½®",
    "difficulty": "easy",
    "type": ["æŸ¥æ‰¾"],
    "icon": "ğŸ”",
    "steps": [
      "æ‰¾åˆ°ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€å°é•¿åº¦",
      "éå†åˆ°æœ€å°é•¿åº¦ï¼Œæ¯”è¾ƒå¯¹åº”ä½ç½®çš„å­—ç¬¦",
      "å¦‚æœå‘ç°ä¸åŒï¼Œè¿”å›å½“å‰ä½ç½®",
      "å¦‚æœéƒ½ç›¸åŒï¼Œæ£€æŸ¥é•¿åº¦å·®å¼‚",
      "è¿”å›ç¬¬ä¸€ä¸ªä¸åŒä½ç½®æˆ–-1"
    ],
    "code": "function findFirstDifference(str1: string, str2: string): number {\n    const minLength = Math.min(str1.length, str2.length);\n\n    for (let i = 0; i < minLength; i++) {\n        if (str1[i] !== str2[i]) {\n            return i;\n        }\n    }\n\n    if (str1.length !== str2.length) {\n        return minLength;\n    }\n\n    return -1;\n}",
    "timeComplexity": "O(min(n,m))",
    "spaceComplexity": "O(1)"
  },
  {
    "id": "stringReverseWords",
    "title": "å•è¯åè½¬",
    "description": "åè½¬å­—ç¬¦ä¸²ä¸­å•è¯çš„é¡ºåºï¼Œä½†ä¿æŒå•è¯å†…éƒ¨å­—ç¬¦é¡ºåº",
    "difficulty": "easy",
    "type": ["å˜æ¢"],
    "icon": "ğŸ”„",
    "steps": [
      "å°†å­—ç¬¦ä¸²æŒ‰ç©ºæ ¼æ‹†åˆ†ä¸ºå•è¯æ•°ç»„",
      "åè½¬å•è¯æ•°ç»„çš„é¡ºåº",
      "å°†åè½¬åçš„å•è¯é‡æ–°è¿æ¥æˆå­—ç¬¦ä¸²",
      "å¤„ç†å¤šä¸ªç©ºæ ¼çš„æƒ…å†µ",
      "è¿”å›åè½¬åçš„å­—ç¬¦ä¸²"
    ],
    "code": "function reverseWords(str: string): string {\n    const words = str.trim().split(/\\s+/);\n    return words.reverse().join(' ');\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "substringSearch",
    "title": "å­ä¸²æŸ¥æ‰¾",
    "description": "åœ¨å­—ç¬¦ä¸²ä¸­æŸ¥æ‰¾æŒ‡å®šå­ä¸²çš„é¦–æ¬¡å‡ºç°ä½ç½®(ä¸ç”¨indexOf)",
    "difficulty": "easy",
    "type": ["æŸ¥æ‰¾"],
    "icon": "ğŸ”",
    "steps": [
      "éå†ä¸»å­—ç¬¦ä¸²çš„æ¯ä¸ªå¯èƒ½èµ·å§‹ä½ç½®",
      "æ¯”è¾ƒä¸»å­—ç¬¦ä¸²ä»å½“å‰ä½ç½®å¼€å§‹çš„å­ä¸²ä¸ç›®æ ‡å­ä¸²",
      "å¦‚æœå®Œå…¨åŒ¹é…åˆ™è¿”å›å½“å‰ç´¢å¼•",
      "éå†ç»“æŸæœªæ‰¾åˆ°åˆ™è¿”å›-1"
    ],
    "code": "function findSubstring(str: string, sub: string): number {\n    if (sub.length > str.length) return -1;\n    for (let i = 0; i <= str.length - sub.length; i++) {\n        if (str.slice(i, i + sub.length) === sub) return i;\n    }\n    return -1;\n}",
    "timeComplexity": "O(n*m)",
    "spaceComplexity": "O(1)"
  },
  {
    "id": "stringReplaceAll",
    "title": "å…¨å±€æ›¿æ¢",
    "description": "å°†å­—ç¬¦ä¸²ä¸­æ‰€æœ‰åŒ¹é…çš„å­ä¸²æ›¿æ¢ä¸ºæ–°å†…å®¹(ä¸ç”¨replaceAll)",
    "difficulty": "easy",
    "type": ["å˜æ¢"],
    "icon": "ğŸ”„",
    "steps": [
      "ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼å…¨å±€åŒ¹é…æ¨¡å¼",
      "è°ƒç”¨replaceæ–¹æ³•è¿›è¡Œæ›¿æ¢",
      "å¤„ç†ç‰¹æ®Šå­—ç¬¦è½¬ä¹‰é—®é¢˜",
      "è¿”å›æ›¿æ¢åçš„æ–°å­—ç¬¦ä¸²"
    ],
    "code": "function replaceAll(str: string, search: string, replacement: string): string {\n    const escapedSearch = search.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n    return str.replace(new RegExp(escapedSearch, 'g'), replacement);\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "stringInsert",
    "title": "å­—ç¬¦ä¸²æ’å…¥",
    "description": "åœ¨æŒ‡å®šä½ç½®æ’å…¥å­å­—ç¬¦ä¸²(ä¸ç”¨splice)",
    "difficulty": "easy",
    "type": ["å˜æ¢"],
    "icon": "ğŸ“¥",
    "steps": [
      "æ£€æŸ¥æ’å…¥ä½ç½®æ˜¯å¦æœ‰æ•ˆ",
      "å°†åŸå­—ç¬¦ä¸²åˆ†å‰²ä¸ºæ’å…¥ç‚¹å‰åçš„ä¸¤éƒ¨åˆ†",
      "å°†ä¸‰éƒ¨åˆ†ï¼ˆå‰æ®µ+æ’å…¥å†…å®¹+åæ®µï¼‰è¿æ¥",
      "è¿”å›æ–°å­—ç¬¦ä¸²"
    ],
    "code": "function insertString(original: string, insertStr: string, position: number): string {\n    if (position < 0) position = 0;\n    if (position > original.length) position = original.length;\n    return original.slice(0, position) + insertStr + original.slice(position);\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "stringRemoveChars",
    "title": "ç§»é™¤æŒ‡å®šå­—ç¬¦",
    "description": "ä»å­—ç¬¦ä¸²ä¸­ç§»é™¤æ‰€æœ‰æŒ‡å®šå­—ç¬¦",
    "difficulty": "easy",
    "type": ["å˜æ¢"],
    "icon": "âŒ",
    "steps": [
      "åˆ›å»ºæ­£åˆ™è¡¨è¾¾å¼åŒ¹é…ç›®æ ‡å­—ç¬¦",
      "ä½¿ç”¨replaceæ–¹æ³•æ›¿æ¢ä¸ºç©ºå­—ç¬¦ä¸²",
      "å¤„ç†å¤šä¸ªå­—ç¬¦çš„æƒ…å†µ",
      "è¿”å›æ¸…ç†åçš„å­—ç¬¦ä¸²"
    ],
    "code": "function removeChars(str: string, chars: string): string {\n    const pattern = `[${chars.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}]`;\n    return str.replace(new RegExp(pattern, 'g'), '');\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "stringSplitMulti",
    "title": "å¤šåˆ†éš”ç¬¦åˆ†å‰²",
    "description": "ä½¿ç”¨å¤šä¸ªåˆ†éš”ç¬¦åˆ†å‰²å­—ç¬¦ä¸²",
    "difficulty": "easy",
    "type": ["å˜æ¢"],
    "icon": "âœ‚ï¸",
    "steps": [
      "æ„å»ºåŒ…å«æ‰€æœ‰åˆ†éš”ç¬¦çš„æ­£åˆ™è¡¨è¾¾å¼",
      "ä½¿ç”¨splitæ–¹æ³•åˆ†å‰²å­—ç¬¦ä¸²",
      "è¿‡æ»¤ç©ºå­—ç¬¦ä¸²ç»“æœ",
      "è¿”å›å•è¯æ•°ç»„"
    ],
    "code": "function splitMultiple(str: string, delimiters: string[]): string[] {\n    const pattern = new RegExp(`[${delimiters.join('')}]`);\n    return str.split(pattern).filter(word => word.length > 0);\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "stringPad",
    "title": "å­—ç¬¦ä¸²å¡«å……",
    "description": "åœ¨å­—ç¬¦ä¸²ä¸¤ä¾§å¡«å……æŒ‡å®šå­—ç¬¦åˆ°ç›®æ ‡é•¿åº¦(ä¸ç”¨padStartå’ŒpadEnd)",
    "difficulty": "easy",
    "type": ["å˜æ¢"],
    "icon": "ğŸ“",
    "steps": [
      "è®¡ç®—éœ€è¦å¡«å……çš„é•¿åº¦",
      "ç”Ÿæˆå¡«å……å­—ç¬¦ç»„æˆçš„å­—ç¬¦ä¸²",
      "æ ¹æ®å¯¹é½æ–¹å¼ï¼ˆå·¦/ä¸­/å³ï¼‰ç»„åˆå­—ç¬¦ä¸²",
      "è¿”å›å¡«å……åçš„ç»“æœ"
    ],
    "code": "function padString(str: string, length: number, char: string = ' ', align: 'left' | 'right' | 'center' = 'left'): string {\n    if (str.length >= length) return str;\n    \n    const padLength = length - str.length;\n    const padStr = char.repeat(Math.ceil(padLength / char.length)).slice(0, padLength);\n    \n    switch(align) {\n        case 'left': return str + padStr;\n        case 'right': return padStr + str;\n        case 'center': \n            const leftPad = Math.floor(padLength / 2);\n            const rightPad = padLength - leftPad;\n            return padStr.slice(0, leftPad) + str + padStr.slice(0, rightPad);\n    }\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "stringIsSubsequence",
    "title": "å­åºåˆ—æ£€æµ‹",
    "description": "åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦æ˜¯å¦ä¸€ä¸ªå­—ç¬¦ä¸²çš„å­åºåˆ—ï¼ˆä¿æŒé¡ºåºï¼‰(ä¸ç”¨indexOfæˆ–è€…includes)",
    "difficulty": "easy",
    "type": ["æŸ¥æ‰¾"],
    "icon": "ğŸ”",
    "steps": [
      "åˆå§‹åŒ–ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«æŒ‡å‘ä¸¤ä¸ªå­—ç¬¦ä¸²å¼€å¤´",
      "éå†ä¸»å­—ç¬¦ä¸²ç§»åŠ¨æŒ‡é’ˆ",
      "å½“å­—ç¬¦åŒ¹é…æ—¶ç§»åŠ¨å­åºåˆ—æŒ‡é’ˆ",
      "æ£€æŸ¥å­åºåˆ—æŒ‡é’ˆæ˜¯å¦éå†å®Œæˆ"
    ],
    "code": "function isSubsequence(sub: string, str: string): boolean {\n    let j = 0;\n    for (let i = 0; i < str.length && j < sub.length; i++) {\n        if (str[i] === sub[j]) j++;\n    }\n    return j === sub.length;\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)"
  },
  {
    "id": "stringCountSubstring",
    "title": "å­ä¸²å‡ºç°æ¬¡æ•°",
    "description": "ç»Ÿè®¡å­ä¸²åœ¨å­—ç¬¦ä¸²ä¸­å‡ºç°çš„æ¬¡æ•°ï¼ˆå…è®¸é‡å ï¼‰",
    "difficulty": "easy",
    "type": ["ç»Ÿè®¡"],
    "icon": "ğŸ”¢",
    "steps": [
      "åˆå§‹åŒ–è®¡æ•°å™¨",
      "éå†å­—ç¬¦ä¸²æ¯ä¸ªèµ·å§‹ä½ç½®",
      "æ£€æŸ¥å½“å‰ä½ç½®æ˜¯å¦åŒ¹é…å­ä¸²",
      "åŒ¹é…æˆåŠŸæ—¶è®¡æ•°å™¨å¢åŠ ",
      "è¿”å›æœ€ç»ˆè®¡æ•°"
    ],
    "code": "function countSubstringOccurrences(str: string, sub: string): number {\n    let count = 0;\n    let pos = 0;\n    while ((pos = str.indexOf(sub, pos)) !== -1) {\n        count++;\n        pos++; // å…è®¸é‡å åŒ¹é…\n    }\n    return count;\n}",
    "timeComplexity": "O(n*m)",
    "spaceComplexity": "O(1)"
  },
  {
    "id": "stringIsIsomorphic",
    "title": "åŒæ„å­—ç¬¦ä¸²æ£€æµ‹",
    "description": "åˆ¤æ–­ä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦åŒæ„ï¼ˆå­—ç¬¦æ˜ å°„å…³ç³»ä¸€è‡´ï¼‰",
    "difficulty": "medium",
    "type": ["æŸ¥æ‰¾"],
    "icon": "ğŸ”„",
    "steps": [
      "åˆ›å»ºä¸¤ä¸ªæ˜ å°„è¡¨è®°å½•å­—ç¬¦å¯¹åº”å…³ç³»",
      "åŒæ—¶éå†ä¸¤ä¸ªå­—ç¬¦ä¸²",
      "æ£€æŸ¥å½“å‰å­—ç¬¦æ˜ å°„æ˜¯å¦ä¸€è‡´",
      "å‘ç°ä¸ä¸€è‡´ç«‹å³è¿”å›false"
    ],
    "code": "function isIsomorphic(s: string, t: string): boolean {\n    if (s.length !== t.length) return false;\n    \n    const sMap = new Map<string, string>();\n    const tMap = new Map<string, string>();\n    \n    for (let i = 0; i < s.length; i++) {\n        const charS = s[i], charT = t[i];\n        \n        if (!sMap.has(charS) && !tMap.has(charT)) {\n            sMap.set(charS, charT);\n            tMap.set(charT, charS);\n        } else if (sMap.get(charS) !== charT || tMap.get(charT) !== charS) {\n            return false;\n        }\n    }\n    return true;\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)"
  },
  {
    "id": "stringReverseVowels",
    "title": "åè½¬å…ƒéŸ³å­—æ¯",
    "description": "åªåè½¬å­—ç¬¦ä¸²ä¸­çš„å…ƒéŸ³å­—æ¯ï¼ˆa,e,i,o,uï¼‰",
    "difficulty": "easy",
    "type": ["å˜æ¢"],
    "icon": "ğŸ”¤",
    "steps": [
      "å®šä¹‰å…ƒéŸ³å­—æ¯é›†åˆ",
      "ä½¿ç”¨åŒæŒ‡é’ˆä»ä¸¤ç«¯å‘ä¸­é—´æ‰«æ",
      "å½“ä¸¤ä¸ªæŒ‡é’ˆéƒ½æŒ‡å‘å…ƒéŸ³æ—¶äº¤æ¢å®ƒä»¬",
      "ç»§ç»­ç§»åŠ¨æŒ‡é’ˆç›´åˆ°ç›¸é‡"
    ],
    "code": "function reverseVowels(str: string): string {\n    const vowels = new Set(['a','e','i','o','u','A','E','I','O','U']);\n    const arr = str.split('');\n    let left = 0, right = str.length - 1;\n    \n    while (left < right) {\n        if (!vowels.has(arr[left])) left++;\n        else if (!vowels.has(arr[right])) right--;\n        else {\n            [arr[left], arr[right]] = [arr[right], arr[left]];\n            left++;\n            right--;\n        }\n    }\n    return arr.join('');\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  }
]
