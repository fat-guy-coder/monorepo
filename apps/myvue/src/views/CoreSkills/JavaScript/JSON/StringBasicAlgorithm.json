[
  {
    "id": "reverse",
    "title": "å­—ç¬¦ä¸²åè½¬",
    "description": "å°†å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦é¡ºåºå®Œå…¨åè½¬",
    "difficulty": "easy",
    "type": ["å˜æ¢"],
    "icon": "ğŸ”",
    "steps": [
      "å°†å­—ç¬¦ä¸²æ‹†åˆ†ä¸ºå­—ç¬¦æ•°ç»„",
      "ä½¿ç”¨æ•°ç»„çš„reverse()æ–¹æ³•åè½¬æ•°ç»„",
      "å°†åè½¬åçš„æ•°ç»„é‡æ–°è¿æ¥æˆå­—ç¬¦ä¸²"
    ],
    "solution": [
      {
        "index": 1,
        "title": "ä½¿ç”¨æ•°ç»„çš„reverse()ç»“åˆæ–¹æ³•åè½¬æ•°ç»„",
        "description": "ä½¿ç”¨æ•°ç»„çš„reverse()ç»“åˆæ–¹æ³•åè½¬æ•°ç»„",
        "code": "function reverseString(str: string): string {\n    return str.split('').reverse().join('');\n}",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)",
        "tips": "ä½¿ç”¨...å±•å¼€å­—ç¬¦ä¸²ï¼Œå°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•°ç»„ï¼Œç„¶åä½¿ç”¨æ•°ç»„çš„reverse()æ–¹æ³•åè½¬æ•°ç»„ï¼Œæœ€åå°†åè½¬åçš„æ•°ç»„é‡æ–°è¿æ¥æˆå­—ç¬¦ä¸²"
      },
      {
        "index": 2,
        "title": "ä½¿ç”¨åŒæŒ‡é’ˆæ³•åè½¬å­—ç¬¦ä¸²",
        "description": "ä½¿ç”¨åŒæŒ‡é’ˆæ³•åè½¬å­—ç¬¦ä¸²ï¼Œä¸€ä¸ªæŒ‡é’ˆä»å¤´éƒ¨å¼€å§‹ï¼Œä¸€ä¸ªæŒ‡é’ˆä»å°¾éƒ¨å¼€å§‹ï¼Œäº¤æ¢ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘çš„å­—ç¬¦ï¼Œç›´åˆ°ä¸¤ä¸ªæŒ‡é’ˆç›¸é‡",
        "code": "function reverseString(str: string): string {\n    let left = 0;\n    let right = str.length - 1;\n    let arr = str.split('');\n    while (left < right) {\n        [arr[left], arr[right]] = [arr[right], arr[left]];\n        left++;\n        right--;\n    }\n    return arr.join('');\n}",
        "timeComplexity": "O(logn)",
        "spaceComplexity": "O(1)"
      },
      {
        "index": 3,
        "title": "ä½¿ç”¨é€’å½’æ³•åè½¬å­—ç¬¦ä¸²",
        "description": "ä½¿ç”¨é€’å½’æ³•åè½¬å­—ç¬¦ä¸²ï¼Œå¦‚æœå­—ç¬¦ä¸²é•¿åº¦å°äºç­‰äº1ï¼Œåˆ™ç›´æ¥è¿”å›å­—ç¬¦ä¸²ï¼Œå¦åˆ™å°†å­—ç¬¦ä¸²çš„ç¬¬ä¸€ä¸ªå­—ç¬¦å’Œå‰©ä½™å­—ç¬¦ä¸²é€’å½’åè½¬",
        "code": "function reverseString(str: string): string {\n    if (str.length <= 1) return str;\n    return reverseString(str.slice(1)) + str[0];\n}",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      {
        "index": 4,
        "title": "ä½¿ç”¨æ ˆåè½¬å­—ç¬¦ä¸²",
        "description": "ä½¿ç”¨æ ˆåè½¬å­—ç¬¦ä¸²ï¼Œå°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•°ç»„ï¼Œç„¶åä½¿ç”¨æ•°ç»„çš„reverse()æ–¹æ³•åè½¬æ•°ç»„ï¼Œæœ€åå°†åè½¬åçš„æ•°ç»„é‡æ–°è¿æ¥æˆå­—ç¬¦ä¸²",
        "code": "function reverseString(str: string): string {\n    const stack = [];\n    for (let i = 0; i < str.length; i++) {\n        stack.push(str[i]);\n    }\n    return stack.reverse().join('');\n}",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      }
    ],
    "code": "function reverseString(str: string): string {\n    return str.split('').reverse().join('');\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)"
  },
  {
    "id": "palindrome",
    "title": "å›æ–‡æ£€æµ‹",
    "description": "åˆ¤æ–­ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦æ­£åºå’Œå€’åºç›¸åŒ",
    "difficulty": "easy",
    "type": ["ç»Ÿè®¡"],
    "icon": "ğŸ”„",
    "steps": [
      "æ¸…ç†å­—ç¬¦ä¸²ï¼ˆç§»é™¤éå­—æ¯æ•°å­—å­—ç¬¦å¹¶è½¬ä¸ºå°å†™ï¼‰",
      "ä½¿ç”¨åŒæŒ‡é’ˆæ³•ï¼Œä¸€ä¸ªä»å¤´éƒ¨å¼€å§‹ï¼Œä¸€ä¸ªä»å°¾éƒ¨å¼€å§‹",
      "æ¯”è¾ƒä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘çš„å­—ç¬¦æ˜¯å¦ç›¸åŒ",
      "å¦‚æœæ‰€æœ‰å­—ç¬¦éƒ½åŒ¹é…ï¼Œåˆ™æ˜¯å›æ–‡"
    ],
    "code": "function isPalindrome(str: string): boolean {\n    const cleanStr = str.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();\n    let left = 0;\n    let right = cleanStr.length - 1;\n\n    while (left < right) {\n        if (cleanStr[left] !== cleanStr[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)"
  },
  {
    "id": "vowel-count",
    "title": "å…ƒéŸ³å­—æ¯è®¡æ•°",
    "description": "è®¡ç®—å­—ç¬¦ä¸²ä¸­å…ƒéŸ³å­—æ¯(a, e, i, o, u)çš„æ•°é‡",
    "difficulty": "easy",
    "type": ["ç»Ÿè®¡"],
    "icon": "ğŸ”¤",
    "steps": [
      "å®šä¹‰ä¸€ä¸ªåŒ…å«æ‰€æœ‰å…ƒéŸ³å­—æ¯çš„é›†åˆ",
      "åˆå§‹åŒ–è®¡æ•°å™¨ä¸º0",
      "éå†å­—ç¬¦ä¸²ä¸­çš„æ¯ä¸ªå­—ç¬¦",
      "å¦‚æœå­—ç¬¦æ˜¯å…ƒéŸ³å­—æ¯ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰ï¼Œåˆ™è®¡æ•°å™¨åŠ 1"
    ],
    "code": "function countVowels(str: string): number {\n    const vowels = new Set(['a', 'e', 'i', 'o', 'u']);\n    let count = 0;\n\n    for (const char of str.toLowerCase()) {\n        if (vowels.has(char)) {\n            count++;\n        }\n    }\n    return count;\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)"
  },
  {
    "id": "anagram",
    "title": "å˜ä½è¯æ£€æµ‹",
    "description": "åˆ¤æ–­ä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦åŒ…å«ç›¸åŒçš„å­—ç¬¦å¹¶ä¸”æ•°é‡ç›¸åŒï¼ˆä¸è€ƒè™‘é¡ºåºï¼‰",
    "difficulty": "easy",
    "type": ["æŸ¥æ‰¾", "ç»Ÿè®¡"],
    "icon": "ğŸ§©",
    "steps": [
      "å¦‚æœä¸¤ä¸ªå­—ç¬¦ä¸²é•¿åº¦ä¸åŒï¼Œç›´æ¥è¿”å›false",
      "åˆ›å»ºä¸€ä¸ªå­—ç¬¦è®¡æ•°å­—å…¸",
      "éå†ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œç»Ÿè®¡æ¯ä¸ªå­—ç¬¦å‡ºç°çš„æ¬¡æ•°",
      "éå†ç¬¬äºŒä¸ªå­—ç¬¦ä¸²ï¼Œå‡å°‘è®¡æ•°å™¨ä¸­å¯¹åº”å­—ç¬¦çš„è®¡æ•°",
      "å¦‚æœæ‰€æœ‰è®¡æ•°éƒ½å˜ä¸º0ï¼Œåˆ™æ˜¯å˜ä½è¯"
    ],
    "code": "function areAnagrams(str1: string, str2: string): boolean {\n    if (str1.length !== str2.length) return false;\n\n    const charCount: Record<string, number> = {};\n\n    for (const char of str1) {\n        charCount[char] = (charCount[char] || 0) + 1;\n    }\n\n    for (const char of str2) {\n        if (!charCount[char]) return false;\n        charCount[char]--;\n    }\n\n    return Object.values(charCount).every(count => count === 0);\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)"
  },
  {
    "id": "capitalize",
    "title": "é¦–å­—æ¯å¤§å†™",
    "description": "å°†å­—ç¬¦ä¸²ä¸­æ¯ä¸ªå•è¯çš„é¦–å­—æ¯è½¬ä¸ºå¤§å†™",
    "difficulty": "easy",
    "type": ["å˜æ¢", "æŸ¥æ‰¾"],
    "icon": "âœ¨",
    "steps": [
      "å°†å­—ç¬¦ä¸²æ‹†åˆ†ä¸ºå•è¯æ•°ç»„",
      "éå†æ¯ä¸ªå•è¯",
      "å°†æ¯ä¸ªå•è¯çš„é¦–å­—æ¯è½¬ä¸ºå¤§å†™ï¼Œå…¶ä½™å­—æ¯è½¬ä¸ºå°å†™",
      "å°†å¤„ç†åçš„å•è¯é‡æ–°è¿æ¥æˆå­—ç¬¦ä¸²"
    ],
    "code": "function capitalizeWords(str: string): string {\n    return str\n        .split(' ')\n        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n        .join(' ');\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "longestWord",
    "title": "æœ€é•¿å•è¯",
    "description": "æ‰¾å‡ºå­—ç¬¦ä¸²ä¸­æœ€é•¿çš„å•è¯",
    "difficulty": "easy",
    "type": ["ç»Ÿè®¡"],
    "icon": "ğŸ“",
    "steps": [
      "ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æˆ–ç©ºæ ¼æ‹†åˆ†å­—ç¬¦ä¸²ä¸ºå•è¯æ•°ç»„",
      "åˆå§‹åŒ–æœ€é•¿å•è¯ä¸ºç©ºå­—ç¬¦ä¸²",
      "éå†æ‰€æœ‰å•è¯",
      "æ¯”è¾ƒæ¯ä¸ªå•è¯çš„é•¿åº¦ï¼Œä¿ç•™æœ€é•¿çš„å•è¯"
    ],
    "code": "function findLongestWord(str: string): string {\n    const words = str.split(/\\s+/);\n    let longestWord = '';\n\n    for (const word of words) {\n        if (word.length > longestWord.length) {\n            longestWord = word;\n        }\n    }\n\n    return longestWord;\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "truncate",
    "title": "å­—ç¬¦ä¸²æˆªæ–­",
    "description": "åœ¨æŒ‡å®šé•¿åº¦å¤„æˆªæ–­å­—ç¬¦ä¸²ï¼Œå¹¶æ·»åŠ çœç•¥å·",
    "difficulty": "easy",
    "type": ["æŸ¥æ‰¾", "æˆªå–"],
    "icon": "âœ‚ï¸",
    "steps": [
      "æ£€æŸ¥å­—ç¬¦ä¸²é•¿åº¦æ˜¯å¦è¶…è¿‡æœ€å¤§é•¿åº¦",
      "å¦‚æœæœªè¶…è¿‡ï¼Œç›´æ¥è¿”å›åŸå­—ç¬¦ä¸²",
      "å¦‚æœè¶…è¿‡ï¼Œæˆªå–åˆ°æœ€å¤§é•¿åº¦å‡3çš„ä½ç½®",
      "åœ¨æœ«å°¾æ·»åŠ çœç•¥å·"
    ],
    "code": "function truncateString(str: string, maxLength: number): string {\n    if (str.length <= maxLength) return str;\n    return str.slice(0, maxLength - 3) + '...';\n}",
    "timeComplexity": "O(1)",
    "spaceComplexity": "O(1)"
  },
  {
    "id": "charCount",
    "title": "å­—ç¬¦å‡ºç°æ¬¡æ•°",
    "description": "è®¡ç®—ç‰¹å®šå­—ç¬¦åœ¨å­—ç¬¦ä¸²ä¸­å‡ºç°çš„æ¬¡æ•°",
    "difficulty": "easy",
    "type": ["æŸ¥æ‰¾", "ç»Ÿè®¡"],
    "icon": "ğŸ”¢",
    "steps": [
      "åˆå§‹åŒ–è®¡æ•°å™¨ä¸º0",
      "éå†å­—ç¬¦ä¸²ä¸­çš„æ¯ä¸ªå­—ç¬¦",
      "å¦‚æœå­—ç¬¦åŒ¹é…ç›®æ ‡å­—ç¬¦ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰ï¼Œè®¡æ•°å™¨åŠ 1",
      "è¿”å›è®¡æ•°ç»“æœ"
    ],
    "code": "function countCharOccurrences(str: string, char: string): number {\n    const targetChar = char.toLowerCase();\n    let count = 0;\n\n    for (const c of str.toLowerCase()) {\n        if (c === targetChar) {\n            count++;\n        }\n    }\n\n    return count;\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)"
  },
  {
    "id": "removeDuplicates",
    "title": "å»é™¤é‡å¤å­—ç¬¦",
    "description": "ç§»é™¤å­—ç¬¦ä¸²ä¸­çš„é‡å¤å­—ç¬¦ï¼Œä¿æŒåŸæœ‰é¡ºåº",
    "difficulty": "easy",
    "type": ["æŸ¥æ‰¾", "æˆªå–"],
    "icon": "ğŸ§¹",
    "steps": [
      "åˆ›å»ºä¸€ä¸ªSetæ¥è·Ÿè¸ªå·²è§è¿‡çš„å­—ç¬¦",
      "åˆ›å»ºä¸€ä¸ªç»“æœå­—ç¬¦ä¸²",
      "éå†åŸå­—ç¬¦ä¸²çš„æ¯ä¸ªå­—ç¬¦",
      "å¦‚æœå­—ç¬¦æœªè§è¿‡ï¼Œæ·»åŠ åˆ°ç»“æœä¸­å¹¶è®°å½•åˆ°Setä¸­",
      "è¿”å›å»é‡åçš„å­—ç¬¦ä¸²"
    ],
    "code": "function removeDuplicates(str: string): string {\n    const seen = new Set<string>();\n    let result = '';\n\n    for (const char of str) {\n        if (!seen.has(char)) {\n            seen.add(char);\n            result += char;\n        }\n    }\n\n    return result;\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "stringRotation",
    "title": "å­—ç¬¦ä¸²æ—‹è½¬",
    "description": "åˆ¤æ–­ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦å¯ä»¥é€šè¿‡æ—‹è½¬å¦ä¸€ä¸ªå­—ç¬¦ä¸²å¾—åˆ°",
    "difficulty": "easy",
    "type": ["æŸ¥æ‰¾", "ç»Ÿè®¡"],
    "icon": "ğŸ”„",
    "steps": [
      "æ£€æŸ¥ä¸¤ä¸ªå­—ç¬¦ä¸²é•¿åº¦æ˜¯å¦ç›¸ç­‰",
      "å°†ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ä¸è‡ªèº«è¿æ¥",
      "æ£€æŸ¥ç¬¬äºŒä¸ªå­—ç¬¦ä¸²æ˜¯å¦æ˜¯è¿æ¥åå­—ç¬¦ä¸²çš„å­ä¸²",
      "å¦‚æœæ˜¯ï¼Œåˆ™å¯ä»¥é€šè¿‡æ—‹è½¬å¾—åˆ°"
    ],
    "code": "function isRotation(str1: string, str2: string): boolean {\n    if (str1.length !== str2.length) return false;\n    const concatenated = str1 + str1;\n    return concatenated.includes(str2);\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "firstNonRepeating",
    "title": "ç¬¬ä¸€ä¸ªéé‡å¤å­—ç¬¦",
    "description": "æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­ç¬¬ä¸€ä¸ªåªå‡ºç°ä¸€æ¬¡çš„å­—ç¬¦",
    "difficulty": "easy",
    "type": ["æŸ¥æ‰¾", "ç»Ÿè®¡"],
    "icon": "ğŸ”",
    "steps": [
      "åˆ›å»ºä¸€ä¸ªMapæ¥ç»Ÿè®¡æ¯ä¸ªå­—ç¬¦çš„å‡ºç°æ¬¡æ•°",
      "ç¬¬ä¸€æ¬¡éå†ï¼šç»Ÿè®¡æ‰€æœ‰å­—ç¬¦çš„å‡ºç°æ¬¡æ•°",
      "ç¬¬äºŒæ¬¡éå†ï¼šæ‰¾åˆ°ç¬¬ä¸€ä¸ªè®¡æ•°ä¸º1çš„å­—ç¬¦",
      "å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œè¿”å›ç©ºå­—ç¬¦ä¸²"
    ],
    "code": "function firstNonRepeatingChar(str: string): string {\n    const charCount = new Map<string, number>();\n\n    for (const char of str) {\n        charCount.set(char, (charCount.get(char) || 0) + 1);\n    }\n\n    for (const char of str) {\n        if (charCount.get(char) === 1) {\n            return char;\n        }\n    }\n\n    return '';\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "stringCompression",
    "title": "å­—ç¬¦ä¸²å‹ç¼©",
    "description": "å°†è¿ç»­é‡å¤å­—ç¬¦å‹ç¼©ä¸ºå­—ç¬¦+æ¬¡æ•°çš„æ ¼å¼",
    "difficulty": "easy",
    "type": ["å˜æ¢", "ç»Ÿè®¡"],
    "icon": "ğŸ—œï¸",
    "steps": [
      "åˆå§‹åŒ–ç»“æœå­—ç¬¦ä¸²å’Œè®¡æ•°å™¨",
      "éå†å­—ç¬¦ä¸²ï¼Œæ¯”è¾ƒå½“å‰å­—ç¬¦ä¸å‰ä¸€ä¸ªå­—ç¬¦",
      "å¦‚æœç›¸åŒï¼Œè®¡æ•°å™¨åŠ 1",
      "å¦‚æœä¸åŒï¼Œå°†å‰ä¸€ä¸ªå­—ç¬¦å’Œè®¡æ•°æ·»åŠ åˆ°ç»“æœä¸­",
      "å¤„ç†æœ€åä¸€ä¸ªå­—ç¬¦ç»„"
    ],
    "code": "function compressString(str: string): string {\n    if (str.length === 0) return str;\n\n    let result = '';\n    let count = 1;\n    let currentChar = str[0];\n\n    for (let i = 1; i < str.length; i++) {\n        if (str[i] === currentChar) {\n            count++;\n        } else {\n            result += currentChar + (count > 1 ? count : '');\n            currentChar = str[i];\n            count = 1;\n        }\n    }\n\n    result += currentChar + (count > 1 ? count : '');\n    return result;\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "validParentheses",
    "title": "æœ‰æ•ˆæ‹¬å·",
    "description": "åˆ¤æ–­å­—ç¬¦ä¸²ä¸­çš„æ‹¬å·æ˜¯å¦æœ‰æ•ˆåŒ¹é…",
    "difficulty": "easy",
    "type": ["æŸ¥æ‰¾", "ç»Ÿè®¡"],
    "icon": "ğŸ“",
    "steps": [
      "åˆ›å»ºä¸€ä¸ªæ ˆæ¥å­˜å‚¨å·¦æ‹¬å·",
      "éå†å­—ç¬¦ä¸²ä¸­çš„æ¯ä¸ªå­—ç¬¦",
      "å¦‚æœæ˜¯å·¦æ‹¬å·ï¼Œå‹å…¥æ ˆä¸­",
      "å¦‚æœæ˜¯å³æ‹¬å·ï¼Œæ£€æŸ¥æ ˆé¡¶æ˜¯å¦åŒ¹é…",
      "æœ€åæ£€æŸ¥æ ˆæ˜¯å¦ä¸ºç©º"
    ],
    "code": "function isValidParentheses(str: string): boolean {\n    const stack: string[] = [];\n    const pairs: Record<string, string> = {\n        ')': '(',\n        '}': '{',\n        ']': '['\n    };\n\n    for (const char of str) {\n        if (pairs[char]) {\n            if (stack.pop() !== pairs[char]) {\n                return false;\n            }\n        } else {\n            stack.push(char);\n        }\n    }\n\n    return stack.length === 0;\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "longestCommonPrefix",
    "title": "æœ€é•¿å…¬å…±å‰ç¼€",
    "description": "æ‰¾åˆ°å­—ç¬¦ä¸²æ•°ç»„ä¸­æœ€é•¿çš„å…¬å…±å‰ç¼€",
    "difficulty": "easy",
    "type": ["æŸ¥æ‰¾"],
    "icon": "ğŸ”—",
    "steps": [
      "å¦‚æœæ•°ç»„ä¸ºç©ºï¼Œè¿”å›ç©ºå­—ç¬¦ä¸²",
      "ä»¥ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ä¸ºåŸºå‡†",
      "éå†ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²çš„æ¯ä¸ªå­—ç¬¦ä½ç½®",
      "æ£€æŸ¥å…¶ä»–å­—ç¬¦ä¸²åœ¨ç›¸åŒä½ç½®æ˜¯å¦åŒ¹é…",
      "è¿”å›åŒ¹é…çš„æœ€é•¿å‰ç¼€"
    ],
    "code": "function longestCommonPrefix(strs: string[]): string {\n    if (strs.length === 0) return '';\n    if (strs.length === 1) return strs[0];\n\n    let prefix = '';\n    const firstStr = strs[0];\n\n    for (let i = 0; i < firstStr.length; i++) {\n        const char = firstStr[i];\n        for (let j = 1; j < strs.length; j++) {\n            if (i >= strs[j].length || strs[j][i] !== char) {\n                return prefix;\n            }\n        }\n        prefix += char;\n    }\n\n    return prefix;\n}",
    "timeComplexity": "O(S)",
    "spaceComplexity": "O(1)"
  },
  {
    "id": "wordFrequency",
    "title": "å•è¯é¢‘ç‡ç»Ÿè®¡",
    "description": "ç»Ÿè®¡å­—ç¬¦ä¸²ä¸­æ¯ä¸ªå•è¯å‡ºç°çš„æ¬¡æ•°",
    "difficulty": "easy",
    "type": ["ç»Ÿè®¡"],
    "icon": "ğŸ“Š",
    "steps": [
      "æ¸…ç†å­—ç¬¦ä¸²ï¼Œç§»é™¤éå­—æ¯å­—ç¬¦",
      "å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºå°å†™å¹¶æ‹†åˆ†ä¸ºå•è¯",
      "åˆ›å»ºä¸€ä¸ªMapæ¥ç»Ÿè®¡å•è¯é¢‘ç‡",
      "éå†å•è¯æ•°ç»„ï¼Œæ›´æ–°è®¡æ•°",
      "è¿”å›å•è¯é¢‘ç‡æ˜ å°„"
    ],
    "code": "function getWordFrequency(str: string): Map<string, number> {\n    const cleanStr = str.replace(/[^a-zA-Z\\s]/g, '').toLowerCase();\n    const words = cleanStr.split(/\\s+/).filter(word => word.length > 0);\n    const frequency = new Map<string, number>();\n\n    for (const word of words) {\n        frequency.set(word, (frequency.get(word) || 0) + 1);\n    }\n\n    return frequency;\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "stringPermutation",
    "title": "å­—ç¬¦ä¸²æ’åˆ—",
    "description": "ç”Ÿæˆå­—ç¬¦ä¸²çš„æ‰€æœ‰å¯èƒ½æ’åˆ—",
    "difficulty": "medium",
    "type": ["ç»Ÿè®¡"],
    "icon": "ğŸ²",
    "steps": [
      "ä½¿ç”¨é€’å½’æ–¹æ³•ç”Ÿæˆæ’åˆ—",
      "å¦‚æœå­—ç¬¦ä¸²é•¿åº¦ä¸º1ï¼Œè¿”å›è¯¥å­—ç¬¦",
      "å¯¹äºæ¯ä¸ªå­—ç¬¦ï¼Œå°†å…¶ä½œä¸ºç¬¬ä¸€ä¸ªå­—ç¬¦",
      "é€’å½’ç”Ÿæˆå‰©ä½™å­—ç¬¦çš„æ’åˆ—",
      "åˆå¹¶æ‰€æœ‰æ’åˆ—ç»“æœ"
    ],
    "code": "function generatePermutations(str: string): string[] {\n    if (str.length <= 1) return [str];\n\n    const permutations: string[] = [];\n\n    for (let i = 0; i < str.length; i++) {\n        const char = str[i];\n        const remaining = str.slice(0, i) + str.slice(i + 1);\n        const subPermutations = generatePermutations(remaining);\n\n        for (const perm of subPermutations) {\n            permutations.push(char + perm);\n        }\n    }\n\n    return permutations;\n}",
    "timeComplexity": "O(n!)",
    "spaceComplexity": "O(n!)"
  },
  {
    "id": "stringEncoding",
    "title": "å­—ç¬¦ä¸²ç¼–ç ",
    "description": "å°†å­—ç¬¦ä¸²ç¼–ç ä¸ºå­—ç¬¦+é‡å¤æ¬¡æ•°çš„æ ¼å¼",
    "difficulty": "easy",
    "type": ["å˜æ¢", "ç»Ÿè®¡"],
    "icon": "ğŸ”",
    "steps": [
      "åˆå§‹åŒ–ç»“æœå­—ç¬¦ä¸²å’Œè®¡æ•°å™¨",
      "éå†å­—ç¬¦ä¸²ï¼Œç»Ÿè®¡è¿ç»­ç›¸åŒå­—ç¬¦",
      "å½“å­—ç¬¦æ”¹å˜æ—¶ï¼Œå°†å‰ä¸€ä¸ªå­—ç¬¦å’Œè®¡æ•°æ·»åŠ åˆ°ç»“æœ",
      "å¤„ç†æœ€åä¸€ä¸ªå­—ç¬¦ç»„",
      "è¿”å›ç¼–ç åçš„å­—ç¬¦ä¸²"
    ],
    "code": "function encodeString(str: string): string {\n    if (str.length === 0) return str;\n\n    let result = '';\n    let count = 1;\n    let currentChar = str[0];\n\n    for (let i = 1; i < str.length; i++) {\n        if (str[i] === currentChar) {\n            count++;\n        } else {\n            result += currentChar + count;\n            currentChar = str[i];\n            count = 1;\n        }\n    }\n\n    result += currentChar + count;\n    return result;\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "stringDecoding",
    "title": "å­—ç¬¦ä¸²è§£ç ",
    "description": "å°†ç¼–ç åçš„å­—ç¬¦ä¸²è§£ç ä¸ºåŸå§‹å­—ç¬¦ä¸²",
    "difficulty": "easy",
    "type": ["å˜æ¢", "ç»Ÿè®¡"],
    "icon": "ğŸ”“",
    "steps": [
      "åˆå§‹åŒ–ç»“æœå­—ç¬¦ä¸²",
      "éå†ç¼–ç å­—ç¬¦ä¸²ï¼Œæå–å­—ç¬¦å’Œæ•°å­—",
      "å°†å­—ç¬¦é‡å¤æŒ‡å®šæ¬¡æ•°",
      "æ·»åŠ åˆ°ç»“æœå­—ç¬¦ä¸²ä¸­",
      "è¿”å›è§£ç åçš„å­—ç¬¦ä¸²"
    ],
    "code": "function decodeString(str: string): string {\n    let result = '';\n    let i = 0;\n\n    while (i < str.length) {\n        const char = str[i];\n        i++;\n        let count = '';\n\n        while (i < str.length && /\\d/.test(str[i])) {\n            count += str[i];\n            i++;\n        }\n\n        const repeatCount = parseInt(count) || 1;\n        result += char.repeat(repeatCount);\n    }\n\n    return result;\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "stringDifference",
    "title": "å­—ç¬¦ä¸²å·®å¼‚",
    "description": "æ‰¾åˆ°ä¸¤ä¸ªå­—ç¬¦ä¸²çš„ç¬¬ä¸€ä¸ªä¸åŒå­—ç¬¦ä½ç½®",
    "difficulty": "easy",
    "type": ["æŸ¥æ‰¾"],
    "icon": "ğŸ”",
    "steps": [
      "æ‰¾åˆ°ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€å°é•¿åº¦",
      "éå†åˆ°æœ€å°é•¿åº¦ï¼Œæ¯”è¾ƒå¯¹åº”ä½ç½®çš„å­—ç¬¦",
      "å¦‚æœå‘ç°ä¸åŒï¼Œè¿”å›å½“å‰ä½ç½®",
      "å¦‚æœéƒ½ç›¸åŒï¼Œæ£€æŸ¥é•¿åº¦å·®å¼‚",
      "è¿”å›ç¬¬ä¸€ä¸ªä¸åŒä½ç½®æˆ–-1"
    ],
    "code": "function findFirstDifference(str1: string, str2: string): number {\n    const minLength = Math.min(str1.length, str2.length);\n\n    for (let i = 0; i < minLength; i++) {\n        if (str1[i] !== str2[i]) {\n            return i;\n        }\n    }\n\n    if (str1.length !== str2.length) {\n        return minLength;\n    }\n\n    return -1;\n}",
    "timeComplexity": "O(min(n,m))",
    "spaceComplexity": "O(1)"
  },
  {
    "id": "stringReverseWords",
    "title": "å•è¯åè½¬",
    "description": "åè½¬å­—ç¬¦ä¸²ä¸­å•è¯çš„é¡ºåºï¼Œä½†ä¿æŒå•è¯å†…éƒ¨å­—ç¬¦é¡ºåº",
    "difficulty": "easy",
    "type": ["å˜æ¢"],
    "icon": "ğŸ”„",
    "steps": [
      "å°†å­—ç¬¦ä¸²æŒ‰ç©ºæ ¼æ‹†åˆ†ä¸ºå•è¯æ•°ç»„",
      "åè½¬å•è¯æ•°ç»„çš„é¡ºåº",
      "å°†åè½¬åçš„å•è¯é‡æ–°è¿æ¥æˆå­—ç¬¦ä¸²",
      "å¤„ç†å¤šä¸ªç©ºæ ¼çš„æƒ…å†µ",
      "è¿”å›åè½¬åçš„å­—ç¬¦ä¸²"
    ],
    "code": "function reverseWords(str: string): string {\n    const words = str.trim().split(/\\s+/);\n    return words.reverse().join(' ');\n}",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "id": "stringPatternMatching",
    "title": "æ¨¡å¼åŒ¹é…",
    "description": "æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦åŒ¹é…ç»™å®šçš„æ¨¡å¼ï¼ˆæ”¯æŒé€šé…ç¬¦ï¼‰",
    "difficulty": "hard",
    "type": ["ç»Ÿè®¡"],
    "icon": "ğŸ¯",
    "steps": [
      "ä½¿ç”¨åŠ¨æ€è§„åˆ’æˆ–é€’å½’æ–¹æ³•",
      "å¤„ç†é€šé…ç¬¦*ï¼ˆåŒ¹é…ä»»æ„å­—ç¬¦åºåˆ—ï¼‰",
      "å¤„ç†é€šé…ç¬¦?ï¼ˆåŒ¹é…å•ä¸ªå­—ç¬¦ï¼‰",
      "æ¯”è¾ƒæ¨¡å¼å­—ç¬¦å’Œå­—ç¬¦ä¸²å­—ç¬¦",
      "è¿”å›æ˜¯å¦åŒ¹é…çš„ç»“æœ"
    ],
    "code": "function isMatch(s: string, p: string): boolean {\n    const dp: boolean[][] = Array(s.length + 1).fill(null).map(() => Array(p.length + 1).fill(false));\n    dp[0][0] = true;\n\n    for (let j = 1; j <= p.length; j++) {\n        if (p[j - 1] === '*') {\n            dp[0][j] = dp[0][j - 1];\n        }\n    }\n\n    for (let i = 1; i <= s.length; i++) {\n        for (let j = 1; j <= p.length; j++) {\n            if (p[j - 1] === '?' || p[j - 1] === s[i - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else if (p[j - 1] === '*') {\n                dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\n            }\n        }\n    }\n\n    return dp[s.length][p.length];\n}",
    "timeComplexity": "O(mn)",
    "spaceComplexity": "O(mn)"
  },
  {
    "id": "stringEditDistance",
    "title": "ç¼–è¾‘è·ç¦»",
    "description": "è®¡ç®—å°†ä¸€ä¸ªå­—ç¬¦ä¸²è½¬æ¢ä¸ºå¦ä¸€ä¸ªå­—ç¬¦ä¸²æ‰€éœ€çš„æœ€å°‘æ“ä½œæ¬¡æ•°",
    "difficulty": "hard",
    "type": ["ç»Ÿè®¡"],
    "icon": "âœï¸",
    "steps": [
      "ä½¿ç”¨åŠ¨æ€è§„åˆ’æ–¹æ³•",
      "åˆ›å»ºäºŒç»´æ•°ç»„å­˜å‚¨å­é—®é¢˜çš„è§£",
      "è€ƒè™‘æ’å…¥ã€åˆ é™¤ã€æ›¿æ¢ä¸‰ç§æ“ä½œ",
      "å¡«å……åŠ¨æ€è§„åˆ’è¡¨",
      "è¿”å›æœ€ç»ˆçš„ç¼–è¾‘è·ç¦»"
    ],
    "code": "function editDistance(word1: string, word2: string): number {\n    const m = word1.length;\n    const n = word2.length;\n    const dp: number[][] = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));\n\n    for (let i = 0; i <= m; i++) {\n        dp[i][0] = i;\n    }\n    for (let j = 0; j <= n; j++) {\n        dp[0][j] = j;\n    }\n\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (word1[i - 1] === word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n\n    return dp[m][n];\n}",
    "timeComplexity": "O(mn)",
    "spaceComplexity": "O(mn)"
  }
]
