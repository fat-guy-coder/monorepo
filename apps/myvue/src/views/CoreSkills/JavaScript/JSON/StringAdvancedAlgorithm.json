[
  {
    "title": "1. 字符串转换整数 (atoi)",
    "id": "atoi",
    "type": ["转换", "边界条件处理"],
    "difficulty": "中等",
    "problem": "实现一个函数，使其能将字符串转换成整数。需要处理可能的符号位和溢出情况。",
    "approach": [
      "去除前导空格",
      "检查正负号",
      "读取数字字符直到非数字字符",
      "处理整数溢出情况",
      "返回转换后的整数"
    ],
    "principle": "遍历字符，对每个不同类型字符进行处理",
    "code": "function myAtoi(str) {\n  str = str.trim();\n  if (!str) return 0;\n\n  let sign = 1;\n  let index = 0;\n\n  // 处理符号\n  if (str[index] === '+' || str[index] === '-') {\n    sign = str[index] === '-' ? -1 : 1;\n    index++;\n  }\n\n  let num = 0;\n  const INT_MAX = Math.pow(2, 31) - 1;\n  const INT_MIN = -Math.pow(2, 31);\n\n  while (index < str.length && str[index] >= '0' && str[index] <= '9') {\n    const digit = str[index] - '0';\n\n    // 检查溢出\n    if (num > Math.floor(INT_MAX / 10) ||\n        (num === Math.floor(INT_MAX / 10) && digit > INT_MAX % 10)) {\n      return sign === 1 ? INT_MAX : INT_MIN;\n    }\n\n    num = num * 10 + digit;\n    index++;\n  }\n\n  return num * sign;\n}",
    "input": "   -42",
    "inputPlaceholder": "输入要转换的字符串",
    "result": "",
    "complexity": "O(n)",
    "spaceComplexity": "O(1)"
  },
  {
    "title": "2. 最长公共前缀",
    "id": "longestCommonPrefix",
    "type": ["遍历", "前缀", "剪枝"],
    "difficulty": "简单",
    "problem": "查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串。",
    "approach": [
      "以第一个字符串作为初始前缀",
      "遍历数组中的每个字符串",
      "将当前前缀与每个字符串比较，缩减前缀直到匹配",
      "如果前缀为空，则提前返回"
    ],
    "principle": "遍历字符匹配前缀，并动态缩减前缀",
    "code": "function longestCommonPrefix(strs) {\n  if (strs.length === 0) return '';\n\n  let prefix = strs[0];\n\n  for (let i = 1; i < strs.length; i++) {\n    // 缩减前缀直到匹配当前字符串\n    while (strs[i].indexOf(prefix) !== 0) {\n      prefix = prefix.substring(0, prefix.length - 1);\n      if (prefix === '') return '';\n    }\n  }\n\n  return prefix;\n}",
    "input": "flower,flow,flight",
    "inputPlaceholder": "输入逗号分隔的字符串",
    "result": "",
    "complexity": "O(mn)",
    "spaceComplexity": "O(1)"
  },
  {
    "title": "3. 字符串相加（大数加法）",
    "difficulty": "中等",
    "problem": "给定两个表示非负整数的字符串，计算它们的和并以字符串形式返回。",
    "id": "addStrings",
    "type": ["数学", "边界条件处理"],
    "approach": [
      "从两个字符串的末尾开始逐位相加",
      "维护进位值",
      "处理不同长度的字符串",
      "处理最后的进位"
    ],
    "principle": "从两个字符串的末尾开始逐位相加，维护进位值，处理不同长度的字符串，处理最后的进位",
    "code": "function addStrings(num1, num2) {\n  let i = num1.length - 1;\n  let j = num2.length - 1;\n  let carry = 0;\n  let result = '';\n\n  while (i >= 0 || j >= 0 || carry > 0) {\n    const digit1 = i >= 0 ? parseInt(num1[i]) : 0;\n    const digit2 = j >= 0 ? parseInt(num2[j]) : 0;\n\n    const sum = digit1 + digit2 + carry;\n    carry = Math.floor(sum / 10);\n    result = (sum % 10) + result;\n\n    i--;\n    j--;\n  }\n\n  return result;\n}",
    "input": "123,456",
    "inputPlaceholder": "输入两个逗号分隔的数字",
    "result": "",
    "complexity": "O(max(m, n))",
    "spaceComplexity": "O(max(m, n))"
  },
  {
    "title": "4. 最长不重复子串",
    "difficulty": "中等",
    "problem": "给定一个字符串，找出其中不含有重复字符的最长子串的长度。",
    "id": "lengthOfLongestSubstring",
    "type": ["遍历", "滑动窗口", "哈希表"],
    "approach": [
      "使用滑动窗口技术",
      "维护一个字符到索引的映射",
      "当遇到重复字符时，移动窗口起始位置",
      "更新最大长度"
    ],
    "principle": "使用滑动窗口技术，维护一个字符到索引的映射，当遇到重复字符时，移动窗口起始位置，更新最大长度",
    "code": "function lengthOfLongestSubstring(s) {\n  const charMap = new Map();\n  let maxLength = 0;\n  let left = 0;\n\n  for (let right = 0; right < s.length; right++) {\n    const char = s[right];\n\n    // 如果字符已存在且在当前窗口内\n    if (charMap.has(char) && charMap.get(char) >= left) {\n      left = charMap.get(char) + 1; // 移动左指针\n    }\n\n    charMap.set(char, right); // 更新字符位置\n    maxLength = Math.max(maxLength, right - left + 1);\n  }\n\n  return maxLength;\n}",
    "input": "abcabcbb",
    "inputPlaceholder": "输入要分析的字符串",
    "result": "",
    "complexity": "O(n)",
    "spaceComplexity": "O(min(n, m))"
  },
  {
    "title": "5. 字符串匹配 (KMP算法)",
    "id": "kmpSearch",
    "type": ["匹配", "KMP算法", "前缀", "动态规划"],
    "difficulty": "困难",
    "problem": "实现 Knuth-Morris-Pratt 算法，在文本字符串中高效查找模式字符串的位置。",
    "approach": [
      "构建模式字符串的部分匹配表（LPS数组）",
      "使用两个指针分别遍历文本和模式",
      "当字符不匹配时，利用LPS数组跳过不必要的比较",
      "返回匹配的起始索引"
    ],
    "principle": "构建模式字符串的部分匹配表（LPS数组），使用两个指针分别遍历文本和模式，当字符不匹配时，利用LPS数组跳过不必要的比较，返回匹配的起始索引",
    "code": "function kmpSearch(text, pattern) {\n  if (pattern.length === 0) return 0;\n\n  // 构建部分匹配表\n  const lps = buildLPS(pattern);\n  const result = [];\n\n  let i = 0; // text指针\n  let j = 0; // pattern指针\n\n  while (i < text.length) {\n    if (text[i] === pattern[j]) {\n      i++;\n      j++;\n    }\n\n    if (j === pattern.length) {\n      result.push(i - j); // 找到匹配\n      j = lps[j - 1];\n    } else if (i < text.length && text[i] !== pattern[j]) {\n      if (j !== 0) {\n        j = lps[j - 1];\n      } else {\n        i++;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction buildLPS(pattern) {\n  const lps = new Array(pattern.length).fill(0);\n  let len = 0;\n  let i = 1;\n\n  while (i < pattern.length) {\n    if (pattern[i] === pattern[len]) {\n      len++;\n      lps[i] = len;\n      i++;\n    } else {\n      if (len !== 0) {\n        len = lps[len - 1];\n      } else {\n        lps[i] = 0;\n        i++;\n      }\n    }\n  }\n\n  return lps;\n}",
    "input": "ABABDABACDABABCABAB,ABABCABAB",
    "inputPlaceholder": "文本,模式",
    "result": "",
    "complexity": "O(n + m)",
    "spaceComplexity": "O(m)"
  },
  {
    "title": "6 有效的括号",
    "difficulty": "简单",
        "problem": "给定一个只包含 '(', ')', '{', '}', '[' 和 ']' 的字符串，判断字符串是否有效。",
    "id": "isValid",
    "type": ["栈", "匹配"],
    "approach": [
      "使用栈数据结构",
      "遇到开括号时压栈",
      "遇到闭括号时检查栈顶元素是否匹配",
      "如果栈为空或不匹配则无效",
      "最后检查栈是否为空"
    ],
    "principle": "使用栈数据结构(因为括号匹配是成对出现的)，遇到开括号时压栈，遇到闭括号时检查栈顶元素是否匹配，如果栈为空或不匹配则无效，最后检查栈是否为空",
    "code": "function isValid(s) {\n  const stack = [];\n  const mapping = {\n    ')': '(',\n    '}': '{',\n    ']': '['\n  };\n\n  for (let char of s) {\n    if (['(', '{', '['].includes(char)) {\n      stack.push(char);\n    } else {\n      if (stack.length === 0 || stack.pop() !== mapping[char]) {\n        return false;\n      }\n    }\n  }\n\n  return stack.length === 0;\n}",
    "input": "()[]{}",
    "inputPlaceholder": "输入括号字符串",
    "result": "",
    "complexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "title": "7. 字符串中第一个唯一字符",
    "difficulty": "简单",
    "problem": "给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。",
    "id": "firstUniqChar",
    "type": ["遍历", "统计", "哈希表"],
    "approach": [
      "遍历字符串，统计每个字符出现的次数",
      "再次遍历字符串，找到第一个出现次数为1的字符",
      "返回该字符的索引，如果没有则返回-1"
    ],
    "principle": "遍历字符串，统计每个字符出现的次数，再次遍历字符串，找到第一个出现次数为1的字符，返回该字符的索引，如果没有则返回-1",
    "code": "function firstUniqChar(s) {\n  const count = {};\n  for (let char of s) {\n    count[char] = (count[char] || 0) + 1;\n  }\n  for (let i = 0; i < s.length; i++) {\n    if (count[s[i]] === 1) return i;\n  }\n  return -1;\n}",
    "input": "leetcode",
    "inputPlaceholder": "输入要查找的字符串",
    "result": "",
    "complexity": "O(n)",
    "spaceComplexity": "O(1)"
  },
  {
    "title": "8. 实现 strStr()（子串查找）",
    "difficulty": "简单",
    "problem": "实现 strStr() 函数，返回子串 needle 在主串 haystack 中首次出现的位置，如果不存在返回 -1。",
    "id": "strStr",
    "type": ["遍历", "子串", "匹配"],
    "principle": "遍历主串，尝试匹配子串(利用substring)，如果匹配成功，返回当前索引，如果遍历结束未找到，返回-1",
    "approach": [
      "遍历主串，尝试匹配子串",
      "如果匹配成功，返回当前索引",
      "如果遍历结束未找到，返回-1"
    ],
    "code": "function strStr(haystack, needle) {\n  if (needle === '') return 0;\n  for (let i = 0; i <= haystack.length - needle.length; i++) {\n    if (haystack.substring(i, i + needle.length) === needle) {\n      return i;\n    }\n  }\n  return -1;\n}",
    "input": "hello, ll",
    "inputPlaceholder": "主串,子串",
    "result": "",
    "complexity": "O((n-m+1)*m)",
    "spaceComplexity": "O(1)"
  },
  {
    "title": "9. 重复的子字符串",
    "difficulty": "简单",
    "problem": "给定一个非空字符串，判断它是否可以由它的一个子串重复多次构成。",
    "id": "repeatedSubstringPattern",
    "type": ["子串", "匹配"],
    "principle": "如果是重复的子串组成的，那么拼接成两倍后，去掉首尾字符(因为有首尾字符一定是重复的子串)，只有中间的字符串是重复的子串，然后整个字符串才能被找到",
    "approach": [
      "将字符串拼接成自身两倍，去掉首尾字符",
      "判断原字符串是否在新字符串中出现",
      "如果出现则可以由子串重复构成"
    ],
    "code": "function repeatedSubstringPattern(s) {\n  return (s + s).slice(1, -1).includes(s);\n}",
    "input": "abab",
    "inputPlaceholder": "输入要判断的字符串",
    "result": "",
    "complexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "title": "10. 最长回文子串",
    "difficulty": "中等",
    "problem": "给定一个字符串 s，找到 s 中最长的回文子串。",
    "id": "longestPalindrome",
    "type": ["遍历", "回文", "动态规划"],
    "principle": "中心扩展法，遍历字符串，以每个字符为中心向两边扩展，分别处理奇数和偶数长度的回文，记录并更新最长回文子串的起止位置",
    "approach": [
      "以每个字符为中心向两边扩展，寻找回文",
      "分别处理奇数和偶数长度的回文",
      "记录并更新最长回文子串的起止位置"
    ],
    "code": "function longestPalindrome(s) {\n  if (!s) return '';\n  let start = 0, end = 0;\n  for (let i = 0; i < s.length; i++) {\n    let len1 = expandAroundCenter(s, i, i);\n    let len2 = expandAroundCenter(s, i, i + 1);\n    let len = Math.max(len1, len2);\n    if (len > end - start) {\n      start = i - Math.floor((len - 1) / 2);\n      end = i + Math.floor(len / 2);\n    }\n  }\n  return s.substring(start, end + 1);\n}\n\nfunction expandAroundCenter(s, left, right) {\n  while (left >= 0 && right < s.length && s[left] === s[right]) {\n    left--;\n    right++;\n  }\n  return right - left - 1;\n}",

    "input": "babad",
    "inputPlaceholder": "输入要查找的字符串",
    "result": "",
    "complexity": "O(n^2)",
    "spaceComplexity": "O(1)"
  },
  {
    "title": "11. 字符串乘法（大数乘法）",
    "difficulty": "中等",
    "problem": "给定两个表示非负整数的字符串，计算它们的乘积并以字符串形式返回。",
    "id": "multiply",
    "type": ["数学", "边界条件处理"],
    "principle": "模拟竖式乘法，从右到左逐位相乘，处理进位，合并所有部分积",
    "approach": ["模拟竖式乘法", "从右到左逐位相乘", "处理进位", "合并所有部分积"],
    "code": "function multiply(num1, num2) {\n  if (num1 === '0' || num2 === '0') return '0';\n\n  const m = num1.length;\n  const n = num2.length;\n  const result = new Array(m + n).fill(0);\n\n  // 从右到左逐位相乘\n  for (let i = m - 1; i >= 0; i--) {\n    for (let j = n - 1; j >= 0; j--) {\n      const product = (num1[i] - '0') * (num2[j] - '0');\n      const sum = result[i + j + 1] + product;\n\n      result[i + j + 1] = sum % 10;\n      result[i + j] += Math.floor(sum / 10);\n    }\n  }\n\n  // 转换为字符串，去除前导零\n  let str = result.join('');\n  while (str[0] === '0' && str.length > 1) {\n    str = str.substring(1);\n  }\n\n  return str;\n}",
    "input": "123,456",
    "inputPlaceholder": "输入两个逗号分隔的数字",
    "result": "",
    "complexity": "O(mn)",
    "spaceComplexity": "O(m + n)"
  },
  {
    "title": "12. 编辑距离（Levenshtein距离）",
    "difficulty": "困难",
    "problem": "给定两个字符串，计算将一个字符串转换为另一个字符串所需的最少操作次数。操作包括插入、删除、替换。",
    "id": "minDistance",
    "type": ["动态规划", "编辑距离"],
    "principle": "使用动态规划，创建二维DP数组，填充边界条件，根据三种操作计算最小距离",
    "approach": ["使用动态规划", "创建二维DP数组", "填充边界条件", "根据三种操作计算最小距离"],
    "code": "function minDistance(word1, word2) {\n  const m = word1.length;\n  const n = word2.length;\n  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0));\n\n  // 填充边界条件\n  for (let i = 0; i <= m; i++) {\n    dp[i][0] = i;\n  }\n  for (let j = 0; j <= n; j++) {\n    dp[0][j] = j;\n  }\n\n  // 填充DP数组\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (word1[i - 1] === word2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1];\n      } else {\n        dp[i][j] = Math.min(\n          dp[i - 1][j] + 1,     // 删除\n          dp[i][j - 1] + 1,     // 插入\n          dp[i - 1][j - 1] + 1  // 替换\n        );\n      }\n    }\n  }\n\n  return dp[m][n];\n}",
    "input": "horse,ros",
    "inputPlaceholder": "字符串1,字符串2",
    "result": "",
    "complexity": "O(mn)",
    "spaceComplexity": "O(mn)"
  },
  {
    "title": "13. 字符串编码解码",
    "difficulty": "困难",
    "problem": "设计一个算法来编码和解码字符串列表。编码是将字符串列表转换为单个字符串，解码是将单个字符串转换回字符串列表。",
    "id": "encode",
    "type": ["编码", "解码", "转换"],
    "principle": "编码：在每个字符串前加上长度和分隔符，解码：根据长度信息提取每个字符串，处理特殊字符和转义",
    "approach": [
      "编码：在每个字符串前加上长度和分隔符",
      "解码：根据长度信息提取每个字符串",
      "处理特殊字符和转义"
    ],
    "code": "function encode(strs) {\n  if (strs.length === 0) return '';\n  return strs.map(str => str.length + '#' + str).join('');\n}\n\nfunction decode(s) {\n  if (s === '') return [];\n  const result = [];\n  let i = 0;\n\n  while (i < s.length) {\n    // 找到分隔符位置\n    const delimiterIndex = s.indexOf('#', i);\n    if (delimiterIndex === -1) break;\n\n    // 提取长度\n    const length = parseInt(s.substring(i, delimiterIndex));\n\n    // 提取字符串\n    const str = s.substring(delimiterIndex + 1, delimiterIndex + 1 + length);\n    result.push(str);\n\n    // 移动到下一个字符串\n    i = delimiterIndex + 1 + length;\n  }\n\n  return result;\n}",
    "input": "hello,world,leetcode",
    "inputPlaceholder": "输入逗号分隔的字符串列表",
    "result": "",
    "complexity": "O(n)",
    "spaceComplexity": "O(n)"
  },
  {
    "title": "14. 正则表达式匹配",
    "difficulty": "困难",
    "problem": "实现支持 '.' 和 '*' 的正则表达式匹配。'.' 匹配任意单个字符，'*' 匹配零个或多个前面的元素。",
    "id": "isMatch",
    "type": ["动态规划", "正则表达式", "匹配"],
    "principle": "使用动态规划，创建二维DP数组，填充边界条件，处理 '.' 和 '*' 的特殊情况，递归或迭代填充DP数组",
    "approach": [
      "使用动态规划",
      "处理空字符串和空模式",
      "处理 '.' 和 '*' 的特殊情况",
      "递归或迭代填充DP数组"
    ],
    "code": "function isMatch(s, p) {\n  const m = s.length;\n  const n = p.length;\n  const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(false));\n\n  // 空字符串和空模式匹配\n  dp[0][0] = true;\n\n  // 处理模式中的 '*' 与空字符串的匹配\n  for (let j = 1; j <= n; j++) {\n    if (p[j - 1] === '*') {\n      dp[0][j] = dp[0][j - 2];\n    }\n  }\n\n  // 填充DP数组\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (p[j - 1] === '.' || p[j - 1] === s[i - 1]) {\n        dp[i][j] = dp[i - 1][j - 1];\n      } else if (p[j - 1] === '*') {\n        dp[i][j] = dp[i][j - 2]; // 匹配0次\n        if (p[j - 2] === '.' || p[j - 2] === s[i - 1]) {\n          dp[i][j] = dp[i][j] || dp[i - 1][j]; // 匹配1次或多次\n        }\n      }\n    }\n  }\n\n  return dp[m][n];\n}",
    "input": "aa,a*",
    "inputPlaceholder": "字符串,模式",
    "result": "",
    "complexity": "O(mn)",
    "spaceComplexity": "O(mn)"
  },
  {
    "title": "15. 字符串压缩",
    "difficulty": "困难",
    "problem": "给定一个字符串，使用计数压缩算法进行压缩。如果压缩后的字符串长度不小于原字符串，则返回原字符串。",
    "id": "compress",
    "type": ["遍历", "统计", "转换"],
    "principle": "遍历字符串，统计连续相同字符的个数，构建压缩后的字符串，比较长度并返回结果",
    "approach": ["遍历字符串，统计连续相同字符的个数", "构建压缩后的字符串", "比较长度并返回结果"],
    "code": "function compress(chars) {\n  if (chars.length <= 1) return chars.length;\n\n  let writeIndex = 0;\n  let readIndex = 0;\n\n  while (readIndex < chars.length) {\n    const currentChar = chars[readIndex];\n    let count = 0;\n\n    // 统计连续相同字符的个数\n    while (readIndex < chars.length && chars[readIndex] === currentChar) {\n      readIndex++;\n      count++;\n    }\n\n    // 写入字符\n    chars[writeIndex] = currentChar;\n    writeIndex++;\n\n    // 写入计数（如果大于1）\n    if (count > 1) {\n      const countStr = count.toString();\n      for (let i = 0; i < countStr.length; i++) {\n        chars[writeIndex] = countStr[i];\n        writeIndex++;\n      }\n    }\n  }\n\n  return writeIndex;\n}",
    "input": "aabbccc",
    "inputPlaceholder": "输入要压缩的字符串",
    "result": "",
    "complexity": "O(n)",
    "spaceComplexity": "O(1)"
  },
  {
    "title": "16. 字符串排列",
    "difficulty": "困难",
      "problem": "给定两个字符串 s1 和 s2，判断 s2 是否包含 s1 的排列。即判断 s2 中是否存在一个子串，其字符组成与 s1 完全相同。",
    "id": "checkInclusion",
    "type": ["遍历", "滑动窗口", "哈希表"],
    "principle": "使用滑动窗口技术，维护字符频率数组，比较窗口内字符频率与目标频率，移动窗口并更新频率",
    "approach": [
      "使用滑动窗口技术",
      "维护字符频率数组",
      "比较窗口内字符频率与目标频率",
      "移动窗口并更新频率"
    ],
    "code": "function checkInclusion(s1, s2) {\n  if (s1.length > s2.length) return false;\n\n  const count1 = new Array(26).fill(0);\n  const count2 = new Array(26).fill(0);\n\n  // 统计s1中字符频率\n  for (let char of s1) {\n    count1[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n  }\n\n  // 滑动窗口\n  for (let i = 0; i < s2.length; i++) {\n    // 添加右边界字符\n    count2[s2[i].charCodeAt(0) - 'a'.charCodeAt(0)]++;\n\n    // 移除左边界字符（当窗口大小超过s1长度时）\n    if (i >= s1.length) {\n      count2[s2[i - s1.length].charCodeAt(0) - 'a'.charCodeAt(0)]--;\n    }\n\n    // 检查频率是否匹配\n    if (arraysEqual(count1, count2)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction arraysEqual(arr1, arr2) {\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) return false;\n  }\n  return true;\n}",
    "input": "ab,eidbaooo",
    "inputPlaceholder": "模式字符串,目标字符串",
    "result": "",
    "complexity": "O(n)",
    "spaceComplexity": "O(1)"
  },
  {
    "title": "19. 字符串分割",
    "difficulty": "困难",
    "problem": "给定一个字符串 s 和一个字符串列表 wordDict，判断 s 是否可以被空格分割成 wordDict 中的单词。",
    "id": "wordBreak",
    "type": ["动态规划", "字符串分割"],
    "principle": "使用动态规划，创建DP数组，初始化空字符串为true，检查每个可能的分割点，如果存在有效分割则标记为true",
    "approach": [
      "使用动态规划",
      "dp[i] 表示前i个字符是否可以分割",
      "检查每个可能的分割点",
      "如果存在有效分割则标记为true"
    ],
    "code": "function wordBreak(s, wordDict) {\n  const wordSet = new Set(wordDict);\n  const n = s.length;\n  const dp = new Array(n + 1).fill(false);\n  dp[0] = true; // 空字符串可以分割\n\n  for (let i = 1; i <= n; i++) {\n    for (let j = 0; j < i; j++) {\n      // 检查从j到i的子串是否在字典中\n      if (dp[j] && wordSet.has(s.substring(j, i))) {\n        dp[i] = true;\n        break;\n      }\n    }\n  }\n\n  return dp[n];\n}",
    "input": "leetcode,leet,code",
    "inputPlaceholder": "字符串,单词1,单词2",
    "result": "",
    "complexity": "O(n^2)",
    "spaceComplexity": "O(n)"
  },
  {
    "title": "20. 字符串转置",
    "difficulty": "困难",
      "problem": "给定一个字符串，按照指定的行数进行Z字形排列，然后按行读取得到新的字符串。",
    "id": "convert",
    "type": ["遍历", "Z字形排列"],
    "principle": "模拟Z字形排列过程，使用数组存储每行的字符，控制方向变化，按行拼接结果",
    "approach": ["模拟Z字形排列过程", "使用数组存储每行的字符", "控制方向变化", "按行拼接结果"],
    "code": "function convert(s, numRows) {\n  if (numRows === 1 || numRows >= s.length) return s;\n\n  const rows = new Array(numRows).fill('');\n  let currentRow = 0;\n  let direction = 1; // 1表示向下，-1表示向上\n\n  for (let char of s) {\n    rows[currentRow] += char;\n\n    // 改变方向\n    if (currentRow === 0) {\n      direction = 1;\n    } else if (currentRow === numRows - 1) {\n      direction = -1;\n    }\n\n    currentRow += direction;\n  }\n\n  return rows.join('');\n}",
    "input": "PAYPALISHIRING,3",
    "inputPlaceholder": "字符串,行数",
    "result": "",
    "complexity": "O(n)",
    "spaceComplexity": "O(n)"
  }
]
