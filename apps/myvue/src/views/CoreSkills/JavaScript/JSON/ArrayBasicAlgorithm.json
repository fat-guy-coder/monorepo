[
  {
    "id": "max",
    "title": "求最大值",
    "description": "找出数组中的最大值",
    "icon": "⬆️",
    "category": "getValue",
    "difficulty": 1,
    "thinking": "利用reduce遍历数组,每次比较当前值和最大值,如果当前值大于最大值,则更新最大值",
    "steps": [],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function findMax(arr: number[]): number {\n  return arr.reduce((max, current) =>\n    current > max ? current : max,\n    Number.NEGATIVE_INFINITY\n  );\n}"
  },
  {
    "id": "min",
    "title": "求最小值",
    "description": "找出数组中的最小值",
    "icon": "⬇️",
    "category": "getValue",
    "difficulty": 1,
    "thinking": "利用reduce遍历数组,每次比较当前值和最小值,如果当前值小于最小值,则更新最小值",
    "steps": [],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function findMin(arr: number[]): number {\n  return arr.reduce((min, current) =>\n    current < min ? current : min,\n    Number.POSITIVE_INFINITY\n  );\n}"
  },
  {
    "id": "avg",
    "title": "求平均值",
    "description": "计算数组元素的平均值",
    "icon": "🧮",
    "category": "getValue",
    "difficulty": 1,
    "thinking": "利用reduce遍历数组,求和,然后除以数组长度",
    "steps": ["利用reduce遍历数组,求和后除以数组长度", "返回平均值"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function calculateAverage(arr: number[]): number {\n  const sum = arr.reduce((acc, val) => acc + val, 0);\n  return sum / arr.length;\n}"
  },
  {
    "id": "sum",
    "title": "数组求和",
    "description": "计算所有元素的总和",
    "icon": "➕",
    "category": "getValue",
    "difficulty": 1,
    "thinking": "利用reduce遍历数组,求和",
    "steps": ["利用reduce遍历数组,求和", "返回总和"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function arraySum(arr: number[]): number {\n  return arr.reduce((sum, current) => sum + current, 0);\n}"
  },
  {
    "id": "product",
    "title": "数组求积",
    "description": "计算所有元素的乘积",
    "icon": "✖️",
    "category": "getValue",
    "difficulty": 1,
    "thinking": "利用reduce遍历数组,求积",
    "steps": ["利用reduce遍历数组,求积", "返回总积"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function arrayProduct(arr: number[]): number {\n  return arr.reduce((product, current) =>\n    product * current, 1\n  );\n}"
  },
  {
    "id": "count",
    "title": "统计每个元素出现的次数",
    "description": "统计数组中每个元素出现的次数",
    "icon": "🔢",
    "category": "count",
    "difficulty": 1,
    "thinking": "遍历数组,利用map记录每个元素出现的次数",
    "steps": ["遍历数组", "利用map记录每个元素出现的次数", "返回map"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function countElement(arr: number[]): number {\n  const map = new Map();\n  for (const item of arr) {\n    map.set(item, (map.get(item) || 0) + 1);\n  }\n  return map;\n}"
  },
  {
    "id": "most",
    "title": "数组求最多(少)出现次数的元素",
    "description": "计算数组中出现次数最多(少)的元素",
    "icon": "🔢",
    "category": "count",
    "difficulty": 1,
    "thinking": "遍历数组,利用map每个元素出现的次数,然后返回出现次数最多(少)的元素",
    "steps": [
      "遍历数组",
      "利用map记录每个元素出现的次数",
      "依次比较出现次数,返回出现次数最多(少)的元素"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function findMostFrequentElement(arr: number[]): number {\n  const map = new Map();\n  for (const item of arr) {\n    map.set(item, (map.get(item) || 0) + 1);\n  }\n  let maxCount = 0;\n  let mostFrequent = null;\n  for (const [key, value] of map) {\n    if (value > maxCount) {\n      maxCount = value;\n      mostFrequent = key;\n    }\n  }\n  return mostFrequent;\n}"
  },
  {
    "id": "random",
    "title": "随机不重复数组",
    "description": "生成指定范围的不重复随机数组",
    "icon": "🎲",
    "category": "creation",
    "difficulty": 1,
    "thinking": "利用set记录每个元素,如果set中没有该元素,则添加到set中,否则继续",
    "steps": ["利用set记录每个元素", "如果set中没有该元素,则添加到set中,否则继续", "返回set"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function generateUniqueRandomArray(\n  length: number,\n  min = 0,\n  max = 100\n): number[] {\n  const set = new Set<number>();\n  while (set.size < length) {\n    const rand = Math.floor(Math.random() * (max - min + 1)) + min;\n    if (!set.has(rand)) {\n      set.add(rand);\n    } else {\n      continue;\n    }\n  }\n  return Array.from(set);\n}"
  },
  {
    "id": "random2",
    "title": "数组乱序",
    "description": "数组乱序",
    "icon": "🎲",
    "category": "transform",
    "difficulty": 1,
    "thinking": "利用sort法和交换法",
    "steps": ["利用sort法和交换法", "返回乱序后的数组"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "//sort法\nfunction shuffleArray(arr: any[]): any[] {\n  return arr.sort(() => Math.random() - 0.5);\n}\n//交换法\nfunction shuffleArray2(arr: any[]): any[] {\n  for (let i = arr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [arr[i], arr[j]] = [arr[j], arr[i]];\n  }\n  return arr;\n}"
  },
  {
    "id": "intersection",
    "title": "数组交集",
    "description": "获取两个数组的交集",
    "icon": "∩",
    "category": "set",
    "difficulty": 1,
    "thinking": "利用set记录每个元素,然后遍历第二个数组,如果set中包含该元素,则添加到结果数组中",
    "steps": [
      "利用set记录每个元素",
      "遍历第二个数组,如果set中包含该元素,则添加到结果数组中",
      "返回结果数组"
    ],
    "timeComplexity": "O(n+m)",
    "spaceComplexity": "O(min(n,m))",
    "code": "function arrayIntersection(arr1: any[], arr2: any[]): any[] {\n  const set = new Set(arr1);\n  return arr2.filter(item => set.has(item));\n}"
  },
  {
    "id": "union",
    "title": "数组并集",
    "description": "获取两个数组的并集",
    "icon": "∪",
    "category": "set",
    "difficulty": 1,
    "thinking": "利用set去重合并后的两个数组",
    "steps": ["利用set去重合并后的两个数组", "返回结果数组"],
    "timeComplexity": "O(n+m)",
    "spaceComplexity": "O(n+m)",
    "code": "function arrayUnion(arr1: any[], arr2: any[]): any[] {\n  return [...new Set([...arr1, ...arr2])];\n}"
  },
  {
    "id": "difference",
    "title": "数组差集",
    "description": "获取两个数组的差集(A-B)",
    "icon": "−",
    "category": "set",
    "difficulty": 1,
    "thinking": "比较两个数组的大小,大的数组遍历同时比较set(小的数组)中是否包含该元素,添加到结果数组中",
    "steps": [
      "比较两个数组的大小",
      "大的数组遍历同时比较set(小的数组)中是否包含该元素,添加到结果数组中",
      "返回结果数组"
    ],
    "timeComplexity": "O(n+m)",
    "spaceComplexity": "O(n)",
    "code": "function arrayDifference(arr1: any[], arr2: any[]): any[] {\n  const  largeArr  =  arr1.length > arr2.length ? arr1 : arr2;\n  const set = new Set(arr1.length > arr2.length ? arr2 : arr1);\n  return largeArr.filter(item => !set.has(item));\n}"
  },
  {
    "id": "symmetric",
    "title": "数组对称差",
    "description": "获取两个数组的对称差集",
    "icon": "∆",
    "category": "set",
    "difficulty": 1,
    "thinking": "利用差集,然后合并两个差集",
    "steps": ["利用差集,然后合并两个差集", "返回结果数组"],
    "timeComplexity": "O(n+m)",
    "spaceComplexity": "O(n+m)",
    "code": "function symmetricDifference(arr1: any[], arr2: any[]): any[] {\n  const diff1 = arrayDifference(arr1, arr2);\n  const diff2 = arrayDifference(arr2, arr1);\n  return [...diff1, ...diff2];\n}"
  },
  {
    "id": "group",
    "title": "将数组分为三组",
    "description": "将数组分为三组,每组的和差不多相等,返回三组",
    "icon": "🔢",
    "difficulty": 2,
    "thinking": "排序后,从大到小,每次把最大的值给到和最小的数组中",
    "steps": ["排序后,从大到小,每次把最大的值给到和最小的数组中", "返回三组"],
    "category": "group",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function  oneToThreeArr(arr){\n let res = [{sum: 0, arr: []}, {sum: 0, arr: []}, {sum: 0, arr: []}]\n arr = arr.slice().sort((a,b) => b - a);\n arr.map(item => {\n let min = res.sort((a,b) => a.sum - b.sum)[0];\n min.sum += item;\n min.arr.push(item);\n })\n return res;\n}"
  },
  {
    "id": "flatten",
    "title": "数组扁平化",
    "description": "将多层嵌套数组扁平化为一维数组",
    "icon": "📏",
    "category": "transform",
    "difficulty": 1,
    "thinking": "利用reduce方法和递归,将数组扁平化",
    "steps": ["利用reduce方法和递归,将数组扁平化", "返回结果数组"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function flattenArray(arr: any[]): any[] {\n  return arr.reduce((flat, item) =>\n    flat.concat(Array.isArray(item) ?\n      flattenArray(item) : item\n    ), []\n  );\n}"
  },
  {
    "id": "chunk",
    "title": "数组分块",
    "description": "将数组分割为指定大小的块",
    "icon": "🔢",
    "category": "group",
    "difficulty": 1,
    "thinking": "利用slice方法,将数组分割为指定大小的块",
    "steps": ["利用slice方法,将数组分割为指定大小的块", "返回结果数组"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function chunkArray(arr: any[], size: number): any[][] {\n  const chunks = [];\n  for (let i = 0; i < arr.length; i += size) {\n    chunks.push(arr.slice(i, i + size));\n  }\n  return chunks;\n}"
  },
  {
    "id": "rotate",
    "title": "数组旋转",
    "description": "将数组向右旋转指定位置",
    "icon": "🔄",
    "category": "transform",
    "difficulty": 1,
    "thinking": "利用slice方法,将数组向右旋转指定位置",
    "steps": ["利用slice方法,将数组向右旋转指定位置", "返回结果数组"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function rotateArray(arr: any[], k: number): any[] {\n  const rotations = k % arr.length;\n  return [\n    ...arr.slice(-rotations),\n    ...arr.slice(0, arr.length - rotations)\n  ];\n}"
  },
  {
    "id": "partition",
    "title": "数组分区",
    "description": "根据条件将数组划分为两部分",
    "icon": "⚖️",
    "category": "group",
    "difficulty": 1,
    "thinking": "利用slice方法,将数组向右旋转指定位置",
    "steps": ["利用slice方法,将数组向右旋转指定位置", "返回结果数组"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function partitionArray(arr: any[], predicate: (item: any) => boolean): any[][] {\n  const trueArr = [];\n  const falseArr = [];\n  arr.forEach(item =>\n    predicate(item) ? trueArr.push(item) : falseArr.push(item)\n  );\n  return [trueArr, falseArr];\n}"
  },
  {
    "id": "zip",
    "title": "数组zip操作",
    "description": "将多个数组合并为一个元组数组",
    "icon": "🤐",
    "category": "transform",
    "difficulty": 2,
    "thinking": "利用slice方法,将数组向右旋转指定位置",
    "steps": ["利用slice方法,将数组向右旋转指定位置", "返回结果数组"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function zipArrays(...arrays: any[][]): any[][] {\n  const maxLength = Math.max(...arrays.map(arr => arr.length));\n  return Array.from({ length: maxLength }, (_, i) =>\n    arrays.map(arr => arr[i])\n  );\n}"
  },
  {
    "id": "prefix-sum",
    "title": "前缀和数组",
    "description": "计算数组的前缀和序列",
    "icon": "📶",
    "category": "math",
    "difficulty": 1,
    "thinking": "迭代计算累计和并存储在新数组中",
    "steps": ["创建长度相同的新数组", "首元素与原数组相同", "后续元素等于前一个前缀和加当前元素值"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function prefixSum(arr: number[]): number[] {\n  const result = new Array(arr.length);\n  result[0] = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    result[i] = result[i - 1] + arr[i];\n  }\n  return result;\n}"
  },
  {
    "id": "spiral",
    "title": "螺旋遍历",
    "description": "螺旋顺序遍历二维数组",
    "icon": "🌀",
    "category": "traversal",
    "difficulty": 3,
    "thinking": "使用四指针定义边界并逐层向内收缩",
    "steps": [
      "初始化上下左右四个边界指针",
      "按右→下→左→上顺序遍历",
      "每完成一个方向收缩对应边界",
      "当边界交错时停止"
    ],
    "timeComplexity": "O(n*m)",
    "spaceComplexity": "O(1)",
    "code": "function spiralOrder(matrix: number[][]): number[] {\n  if (!matrix.length) return [];\n  const result = [];\n  let top = 0, bottom = matrix.length - 1;\n  let left = 0, right = matrix[0].length - 1;\n  \n  while (top <= bottom && left <= right) {\n    for (let i = left; i <= right; i++) result.push(matrix[top][i]);\n    top++;\n    \n    for (let i = top; i <= bottom; i++) result.push(matrix[i][right]);\n    right--;\n    \n    if (top <= bottom) {\n      for (let i = right; i >= left; i--) result.push(matrix[bottom][i]);\n      bottom--;\n    }\n    \n    if (left <= right) {\n      for (let i = bottom; i >= top; i--) result.push(matrix[i][left]);\n      left++;\n    }\n  }\n  return result;\n}"
  },
  {
    "id": "max-subarray",
    "title": "最大子数组和",
    "description": "寻找连续子数组的最大和",
    "icon": "📈",
    "category": "math",
    "difficulty": 2,
    "thinking": "Kadane算法动态更新当前和与最大和",
    "steps": [
      "初始化当前和与最大和为第一个元素",
      "遍历数组更新当前和（取当前元素或与前面合并）",
      "比较更新全局最大和"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function maxSubarraySum(arr: number[]): number {\n  let maxSum = arr[0];\n  let currentSum = arr[0];\n  \n  for (let i = 1; i < arr.length; i++) {\n    currentSum = Math.max(arr[i], currentSum + arr[i]);\n    maxSum = Math.max(maxSum, currentSum);\n  }\n  return maxSum;\n}"
  },
  {
    "id": "mode",
    "title": "数组众数",
    "description": "找出所有出现频率最高的元素",
    "icon": "🔢",
    "category": "count",
    "difficulty": 2,
    "thinking": "先统计频率再筛选出所有最大频率元素",
    "steps": ["使用Map统计元素频率", "记录最高频率值", "筛选出所有等于最高频率的元素"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function findMode(arr: any[]): any[] {\n  const freq = new Map();\n  let maxFreq = 0;\n  \n  for (const item of arr) {\n    const count = (freq.get(item) || 0) + 1;\n    freq.set(item, count);\n    maxFreq = Math.max(maxFreq, count);\n  }\n  \n  return Array.from(freq.entries())\n    .filter(([_, count]) => count === maxFreq)\n    .map(([item]) => item);\n}"
  },
  {
    "id": "transpose",
    "title": "矩阵转置",
    "description": "二维数组行列互换",
    "icon": "🔄",
    "category": "transform",
    "difficulty": 2,
    "thinking": "通过行列索引互换创建新矩阵",
    "steps": ["创建新数组（列数变行数）", "双层循环交换行列索引"],
    "timeComplexity": "O(n*m)",
    "spaceComplexity": "O(n*m)",
    "code": "function transpose(matrix: any[][]): any[][] {\n  return matrix[0].map((_, colIndex) =>\n    matrix.map(row => row[colIndex])\n  );\n}"
  },
  {
    "id": "deep-clone",
    "title": "深度克隆数组",
    "description": "递归克隆嵌套数组结构",
    "icon": "📋",
    "category": "creation",
    "difficulty": 2,
    "thinking": "递归处理嵌套数组结构",
    "steps": [
      "基本类型直接返回",
      "数组类型递归克隆每个元素",
      "对象类型单独处理（本函数仅处理数组）"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function deepCloneArray(arr: any[]): any[] {\n  return arr.map(item => \n    Array.isArray(item) ? deepCloneArray(item) : item\n  );\n}"
  },
  {
    "id": "group-by",
    "title": "条件分组",
    "description": "按函数返回值分组数组元素",
    "icon": "🗂️",
    "category": "group",
    "difficulty": 2,
    "thinking": "使用Map动态创建分组",
    "steps": ["遍历数组计算分组键", "按键值存储到Map中", "转换Map为分组对象"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function groupBy(arr: any[], fn: (item: any) => string) {\n  return arr.reduce((groups, item) => {\n    const key = fn(item);\n    if (!groups[key]) groups[key] = [];\n    groups[key].push(item);\n    return groups;\n  }, {});\n}"
  },
  {
    "id": "permutations",
    "title": "数组排列",
    "description": "生成数组元素的所有排列",
    "icon": "🔄",
    "category": "count",
    "difficulty": 3,
    "thinking": "递归交换元素位置生成全排列",
    "steps": [
      "基线条件：单元素数组直接返回",
      "递归取出首元素生成子排列",
      "将首元素插入子排列的所有位置"
    ],
    "timeComplexity": "O(n!)",
    "spaceComplexity": "O(n!)",
    "code": "function permutations(arr: any[]): any[][] {\n  if (arr.length <= 1) return [arr];\n  const [first, ...rest] = arr;\n  return permutations(rest).flatMap(perm => \n    Array.from({length: perm.length + 1}, (_, i) =>\n      [...perm.slice(0, i), first, ...perm.slice(i)]\n    )\n  );\n}"
  },
  {
    "id": "diff-array",
    "title": "差分数组",
    "description": "构建快速区间操作的差分数组",
    "icon": "📊",
    "category": "math",
    "difficulty": 2,
    "thinking": "利用相邻元素的差值构造辅助数组",
    "steps": [
      "首元素与原数组相同",
      "后续元素等于当前原数组值减前一个原数组值",
      "通过前缀和可恢复原数组"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function createDiffArray(arr: number[]): number[] {\n  const diff = new Array(arr.length);\n  diff[0] = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    diff[i] = arr[i] - arr[i - 1];\n  }\n  return diff;\n}"
  },
  {
    "id": "dot-product",
    "title": "点积运算",
    "description": "计算两个向量的点积",
    "icon": "⨀",
    "category": "math",
    "difficulty": 1,
    "thinking": "对应位置相乘后求和",
    "steps": ["验证向量长度相同", "逐元素相乘并累加结果"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function dotProduct(vecA: number[], vecB: number[]): number {\n  if (vecA.length !== vecB.length) throw new Error('Vectors must have same length');\n  return vecA.reduce((sum, val, i) => sum + val * vecB[i], 0);\n}"
  },
  {
    "id": "fisher-yates",
    "title": "Fisher-Yates洗牌",
    "description": "均匀随机打乱数组元素的算法",
    "icon": "🎴",
    "category": "transform",
    "difficulty": 2,
    "thinking": "逆向遍历并随机交换元素位置",
    "steps": ["从后向前遍历数组", "随机选择当前位置之前的索引", "交换当前元素与随机选中元素"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function fisherYatesShuffle(arr: any[]): any[] {\n  for (let i = arr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [arr[i], arr[j]] = [arr[j], arr[i]];\n  }\n  return arr;\n}"
  },
  {
    "id": "array-equal",
    "title": "数组相等性",
    "description": "深度比较两个数组是否完全相同",
    "icon": "⚖️",
    "category": "comparison",
    "difficulty": 2,
    "thinking": "递归比较嵌套结构和元素值",
    "steps": ["长度不同直接返回false", "递归比较嵌套数组", "严格比较基本类型值"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function arraysEqual(a: any[], b: any[]): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (Array.isArray(a[i]) && Array.isArray(b[i])) {\n      if (!arraysEqual(a[i], b[i])) return false;\n    } else if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}"
  },
  {
    "id": "binary-search",
    "title": "二分查找",
    "description": "在有序数组中查找目标元素的位置",
    "icon": "🔍",
    "category": "search",
    "difficulty": 2,
    "thinking": "通过不断缩小搜索范围定位目标元素",
    "steps": [
      "初始化左右指针指向数组首尾",
      "计算中间索引并与目标比较",
      "根据比较结果移动左右指针",
      "找到返回索引，否则返回-1"
    ],
    "timeComplexity": "O(log n)",
    "spaceComplexity": "O(1)",
    "code": "function binarySearch(arr: number[], target: number): number {\n  let left = 0;\n  let right = arr.length - 1;\n  \n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) return mid;\n    if (arr[mid] < target) left = mid + 1;\n    else right = mid - 1;\n  }\n  \n  return -1;\n}"
  },
  {
    "id": "range",
    "title": "生成数值范围数组",
    "description": "生成指定范围内的数值数组",
    "icon": "↔️",
    "category": "creation",
    "difficulty": 1,
    "thinking": "使用循环或Array.from生成连续数值序列",
    "steps": ["计算数组长度", "生成从起始值到结束值的序列", "返回结果数组"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function generateRange(start: number, end: number, step = 1): number[] {\n  const length = Math.floor((end - start) / step) + 1;\n  return Array.from({ length }, (_, i) => start + i * step);\n}"
  },
  {
    "id": "fill-pattern",
    "title": "模式填充数组",
    "description": "使用指定模式填充数组",
    "icon": "🔄",
    "category": "creation",
    "difficulty": 1,
    "thinking": "循环应用模式序列填充数组",
    "steps": ["根据模式长度创建填充函数", "循环应用模式到每个位置", "返回填充后的数组"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function fillWithPattern(length: number, pattern: any[]): any[] {\n  return Array.from({ length }, (_, i) => pattern[i % pattern.length]);\n}"
  },
  {
    "id": "unique",
    "title": "数组唯一化",
    "description": "移除数组中重复的元素",
    "icon": "✨",
    "category": "transform",
    "difficulty": 1,
    "thinking": "利用Set数据结构自动去重",
    "steps": ["创建Set实例传入数组", "将Set转换回数组", "返回去重后的数组"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function uniqueArray(arr: any[]): any[] {\n  return [...new Set(arr)];\n}"
  },
  {
    "id": "reverse",
    "title": "数组反转",
    "description": "反转数组元素的顺序",
    "icon": "🔄",
    "category": "transform",
    "difficulty": 1,
    "thinking": "双指针从两端向中间交换元素",
    "steps": ["初始化左右指针", "交换指针位置元素并向中间移动", "返回反转后的数组"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function reverseArray(arr: any[]): any[] {\n  const result = [...arr];\n  let left = 0, right = result.length - 1;\n  \n  while (left < right) {\n    [result[left], result[right]] = [result[right], result[left]];\n    left++;\n    right--;\n  }\n  \n  return result;\n}"
  },
  {
    "id": "move-zeros",
    "title": "移动零元素",
    "description": "将所有0移动到数组末尾并保持非零元素顺序",
    "icon": "⏩",
    "category": "transform",
    "difficulty": 1,
    "thinking": "双指针法：慢指针记录非零位置，快指针遍历数组",
    "steps": [
      "初始化慢指针为0",
      "快指针遍历数组，发现非零元素则复制到慢指针位置",
      "慢指针后移",
      "剩余位置填充0"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function moveZeros(arr: number[]): number[] {\n  let nonZeroIndex = 0;\n  \n  // 移动非零元素\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] !== 0) {\n      arr[nonZeroIndex++] = arr[i];\n    }\n  }\n  \n  // 剩余位置填0\n  for (let i = nonZeroIndex; i < arr.length; i++) {\n    arr[i] = 0;\n  }\n  \n  return arr;\n}"
  },
  {
    "id": "window-sum",
    "title": "滑动窗口求和",
    "description": "计算固定大小窗口内的元素和",
    "icon": "🪟",
    "category": "math",
    "difficulty": 2,
    "thinking": "使用滑动窗口技术避免重复计算",
    "steps": ["计算初始窗口和", "滑动窗口：减去离开元素，加上新进入元素", "记录每个窗口的和"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function slidingWindowSum(arr: number[], k: number): number[] {\n  const result = [];\n  let windowSum = 0;\n  \n  // 计算初始窗口和\n  for (let i = 0; i < k; i++) {\n    windowSum += arr[i];\n  }\n  result.push(windowSum);\n  \n  // 滑动窗口\n  for (let i = k; i < arr.length; i++) {\n    windowSum = windowSum - arr[i - k] + arr[i];\n    result.push(windowSum);\n  }\n  \n  return result;\n}"
  },
  {
    "id": "compress",
    "title": "数组压缩",
    "description": "移除连续重复元素",
    "icon": "🗜️",
    "category": "transform",
    "difficulty": 1,
    "thinking": "遍历数组只保留与前一个不同的元素",
    "steps": [
      "创建结果数组",
      "遍历数组，比较当前元素与前一个",
      "只添加与前一个不同的元素",
      "返回压缩后的数组"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function compressArray(arr: any[]): any[] {\n  return arr.filter((item, index) => index === 0 || item !== arr[index - 1]);\n}"
  },
  {
    "id": "run-length-encoding",
    "title": "游程编码",
    "description": "将连续重复元素编码为[元素, 次数]",
    "icon": "🎚️",
    "category": "transform",
    "difficulty": 2,
    "thinking": "遍历数组统计连续相同元素的个数",
    "steps": [
      "初始化结果数组和当前计数",
      "遍历数组比较当前与前一个元素",
      "相同则计数增加，不同则记录前一组",
      "返回编码结果"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function runLengthEncoding(arr: any[]): [any, number][] {\n  if (arr.length === 0) return [];\n  \n  const result: [any, number][] = [];\n  let current = arr[0];\n  let count = 1;\n  \n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] === current) {\n      count++;\n    } else {\n      result.push([current, count]);\n      current = arr[i];\n      count = 1;\n    }\n  }\n  \n  result.push([current, count]);\n  return result;\n}"
  },
  {
    "id": "fill-array",
    "title": "数组填充",
    "description": "用生成器函数填充数组",
    "icon": "🖌️",
    "category": "creation",
    "difficulty": 2,
    "thinking": "使用生成器函数动态创建数组元素",
    "steps": ["定义元素生成器函数", "循环生成指定数量的元素", "返回填充后的数组"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function fillArray<T>(length: number, generator: (index: number) => T): T[] {\n  return Array.from({ length }, (_, i) => generator(i));\n}"
  },
  {
    "id": "find-pairs",
    "title": "查找和为目标值的元素对",
    "description": "查找所有和为指定目标值的元素对",
    "icon": "👫",
    "category": "search",
    "difficulty": 2,
    "thinking": "使用哈希表记录元素索引",
    "steps": [
      "创建Map存储元素索引",
      "遍历数组，计算目标差值",
      "在Map中查找差值，找到则记录元素对",
      "返回所有符合条件的元素对"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function findPairs(arr: number[], target: number): [number, number][] {\n  const map = new Map<number, number>();\n  const pairs: [number, number][] = [];\n  \n  for (let i = 0; i < arr.length; i++) {\n    const complement = target - arr[i];\n    \n    if (map.has(complement)) {\n      pairs.push([complement, arr[i]]);\n    }\n    \n    map.set(arr[i], i);\n  }\n  \n  return pairs;\n}"
  },
  {
    "id": "array-diff",
    "title": "数组差异",
    "description": "比较两个数组的差异",
    "icon": "🔍",
    "category": "search",
    "difficulty": 2,
    "thinking": "找出新增、删除和更新的元素",
    "steps": [
      "创建Map存储旧数组索引",
      "遍历新数组，识别更新和新增",
      "检查旧数组未被使用的元素作为删除",
      "返回差异结果"
    ],
    "timeComplexity": "O(n+m)",
    "spaceComplexity": "O(n+m)",
    "code": "function arrayDiff<T>(oldArr: T[], newArr: T[]): {\n  added: T[],\n  removed: T[],\n  updated: T[]\n} {\n  const oldMap = new Map<T, number>();\n  oldArr.forEach((item, index) => oldMap.set(item, index));\n  \n  const added: T[] = [];\n  const updated: T[] = [];\n  const newSet = new Set(newArr);\n  \n  newArr.forEach((item, index) => {\n    if (!oldMap.has(item)) {\n      added.push(item);\n    } else if (oldMap.get(item) !== index) {\n      updated.push(item);\n    }\n  });\n  \n  const removed = oldArr.filter(item => !newSet.has(item));\n  \n  return { added, removed, updated };\n}"
  }
]
