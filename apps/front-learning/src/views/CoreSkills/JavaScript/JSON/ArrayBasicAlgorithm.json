[
  {
    "id": "max",
    "title": "æ±‚æœ€å¤§å€¼",
    "description": "æ‰¾å‡ºæ•°ç»„ä¸­çš„æœ€å¤§å€¼",
    "icon": "â¬†ï¸",
    "category": "getValue",
    "difficulty": 1,
    "thinking": "åˆ©ç”¨reduceéå†æ•°ç»„,æ¯æ¬¡æ¯”è¾ƒå½“å‰å€¼å’Œæœ€å¤§å€¼,å¦‚æœå½“å‰å€¼å¤§äºæœ€å¤§å€¼,åˆ™æ›´æ–°æœ€å¤§å€¼",
    "steps": [],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function findMax(arr: number[]): number {\n  return arr.reduce((max, current) =>\n    current > max ? current : max,\n    Number.NEGATIVE_INFINITY\n  );\n}"
  },
  {
    "id": "min",
    "title": "æ±‚æœ€å°å€¼",
    "description": "æ‰¾å‡ºæ•°ç»„ä¸­çš„æœ€å°å€¼",
    "icon": "â¬‡ï¸",
    "category": "getValue",
    "difficulty": 1,
    "thinking": "åˆ©ç”¨reduceéå†æ•°ç»„,æ¯æ¬¡æ¯”è¾ƒå½“å‰å€¼å’Œæœ€å°å€¼,å¦‚æœå½“å‰å€¼å°äºæœ€å°å€¼,åˆ™æ›´æ–°æœ€å°å€¼",
    "steps": [],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function findMin(arr: number[]): number {\n  return arr.reduce((min, current) =>\n    current < min ? current : min,\n    Number.POSITIVE_INFINITY\n  );\n}"
  },
  {
    "id": "avg",
    "title": "æ±‚å¹³å‡å€¼",
    "description": "è®¡ç®—æ•°ç»„å…ƒç´ çš„å¹³å‡å€¼",
    "icon": "ğŸ§®",
    "category": "getValue",
    "difficulty": 1,
    "thinking": "åˆ©ç”¨reduceéå†æ•°ç»„,æ±‚å’Œ,ç„¶åé™¤ä»¥æ•°ç»„é•¿åº¦",
    "steps": ["åˆ©ç”¨reduceéå†æ•°ç»„,æ±‚å’Œåé™¤ä»¥æ•°ç»„é•¿åº¦", "è¿”å›å¹³å‡å€¼"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function calculateAverage(arr: number[]): number {\n  const sum = arr.reduce((acc, val) => acc + val, 0);\n  return sum / arr.length;\n}"
  },
  {
    "id": "sum",
    "title": "æ•°ç»„æ±‚å’Œ",
    "description": "è®¡ç®—æ‰€æœ‰å…ƒç´ çš„æ€»å’Œ",
    "icon": "â•",
    "category": "getValue",
    "difficulty": 1,
    "thinking": "åˆ©ç”¨reduceéå†æ•°ç»„,æ±‚å’Œ",
    "steps": ["åˆ©ç”¨reduceéå†æ•°ç»„,æ±‚å’Œ", "è¿”å›æ€»å’Œ"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function arraySum(arr: number[]): number {\n  return arr.reduce((sum, current) => sum + current, 0);\n}"
  },
  {
    "id": "product",
    "title": "æ•°ç»„æ±‚ç§¯",
    "description": "è®¡ç®—æ‰€æœ‰å…ƒç´ çš„ä¹˜ç§¯",
    "icon": "âœ–ï¸",
    "category": "getValue",
    "difficulty": 1,
    "thinking": "åˆ©ç”¨reduceéå†æ•°ç»„,æ±‚ç§¯",
    "steps": ["åˆ©ç”¨reduceéå†æ•°ç»„,æ±‚ç§¯", "è¿”å›æ€»ç§¯"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function arrayProduct(arr: number[]): number {\n  return arr.reduce((product, current) =>\n    product * current, 1\n  );\n}"
  },
  {
    "id": "count",
    "title": "ç»Ÿè®¡æ¯ä¸ªå…ƒç´ å‡ºç°çš„æ¬¡æ•°",
    "description": "ç»Ÿè®¡æ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ å‡ºç°çš„æ¬¡æ•°",
    "icon": "ğŸ”¢",
    "category": "count",
    "difficulty": 1,
    "thinking": "éå†æ•°ç»„,åˆ©ç”¨mapè®°å½•æ¯ä¸ªå…ƒç´ å‡ºç°çš„æ¬¡æ•°",
    "steps": ["éå†æ•°ç»„", "åˆ©ç”¨mapè®°å½•æ¯ä¸ªå…ƒç´ å‡ºç°çš„æ¬¡æ•°", "è¿”å›map"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function countElement(arr: number[]): number {\n  const map = new Map();\n  for (const item of arr) {\n    map.set(item, (map.get(item) || 0) + 1);\n  }\n  return map;\n}"
  },
  {
    "id": "most",
    "title": "æ•°ç»„æ±‚æœ€å¤š(å°‘)å‡ºç°æ¬¡æ•°çš„å…ƒç´ ",
    "description": "è®¡ç®—æ•°ç»„ä¸­å‡ºç°æ¬¡æ•°æœ€å¤š(å°‘)çš„å…ƒç´ ",
    "icon": "ğŸ”¢",
    "category": "count",
    "difficulty": 1,
    "thinking": "éå†æ•°ç»„,åˆ©ç”¨mapæ¯ä¸ªå…ƒç´ å‡ºç°çš„æ¬¡æ•°,ç„¶åè¿”å›å‡ºç°æ¬¡æ•°æœ€å¤š(å°‘)çš„å…ƒç´ ",
    "steps": [
      "éå†æ•°ç»„",
      "åˆ©ç”¨mapè®°å½•æ¯ä¸ªå…ƒç´ å‡ºç°çš„æ¬¡æ•°",
      "ä¾æ¬¡æ¯”è¾ƒå‡ºç°æ¬¡æ•°,è¿”å›å‡ºç°æ¬¡æ•°æœ€å¤š(å°‘)çš„å…ƒç´ "
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function findMostFrequentElement(arr: number[]): number {\n  const map = new Map();\n  for (const item of arr) {\n    map.set(item, (map.get(item) || 0) + 1);\n  }\n  let maxCount = 0;\n  let mostFrequent = null;\n  for (const [key, value] of map) {\n    if (value > maxCount) {\n      maxCount = value;\n      mostFrequent = key;\n    }\n  }\n  return mostFrequent;\n}"
  },
  {
    "id": "random",
    "title": "éšæœºä¸é‡å¤æ•°ç»„",
    "description": "ç”ŸæˆæŒ‡å®šèŒƒå›´çš„ä¸é‡å¤éšæœºæ•°ç»„",
    "icon": "ğŸ²",
    "category": "creation",
    "difficulty": 1,
    "thinking": "åˆ©ç”¨setè®°å½•æ¯ä¸ªå…ƒç´ ,å¦‚æœsetä¸­æ²¡æœ‰è¯¥å…ƒç´ ,åˆ™æ·»åŠ åˆ°setä¸­,å¦åˆ™ç»§ç»­",
    "steps": ["åˆ©ç”¨setè®°å½•æ¯ä¸ªå…ƒç´ ", "å¦‚æœsetä¸­æ²¡æœ‰è¯¥å…ƒç´ ,åˆ™æ·»åŠ åˆ°setä¸­,å¦åˆ™ç»§ç»­", "è¿”å›set"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function generateUniqueRandomArray(\n  length: number,\n  min = 0,\n  max = 100\n): number[] {\n  const set = new Set<number>();\n  while (set.size < length) {\n    const rand = Math.floor(Math.random() * (max - min + 1)) + min;\n    if (!set.has(rand)) {\n      set.add(rand);\n    } else {\n      continue;\n    }\n  }\n  return Array.from(set);\n}"
  },
  {
    "id": "random2",
    "title": "æ•°ç»„ä¹±åº",
    "description": "æ•°ç»„ä¹±åº",
    "icon": "ğŸ²",
    "category": "transform",
    "difficulty": 1,
    "thinking": "åˆ©ç”¨sortæ³•å’Œäº¤æ¢æ³•",
    "steps": ["åˆ©ç”¨sortæ³•å’Œäº¤æ¢æ³•", "è¿”å›ä¹±åºåçš„æ•°ç»„"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "//sortæ³•\nfunction shuffleArray(arr: any[]): any[] {\n  return arr.sort(() => Math.random() - 0.5);\n}\n//äº¤æ¢æ³•\nfunction shuffleArray2(arr: any[]): any[] {\n  for (let i = arr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [arr[i], arr[j]] = [arr[j], arr[i]];\n  }\n  return arr;\n}"
  },
  {
    "id": "intersection",
    "title": "æ•°ç»„äº¤é›†",
    "description": "è·å–ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†",
    "icon": "âˆ©",
    "category": "set",
    "difficulty": 1,
    "thinking": "åˆ©ç”¨setè®°å½•æ¯ä¸ªå…ƒç´ ,ç„¶åéå†ç¬¬äºŒä¸ªæ•°ç»„,å¦‚æœsetä¸­åŒ…å«è¯¥å…ƒç´ ,åˆ™æ·»åŠ åˆ°ç»“æœæ•°ç»„ä¸­",
    "steps": [
      "åˆ©ç”¨setè®°å½•æ¯ä¸ªå…ƒç´ ",
      "éå†ç¬¬äºŒä¸ªæ•°ç»„,å¦‚æœsetä¸­åŒ…å«è¯¥å…ƒç´ ,åˆ™æ·»åŠ åˆ°ç»“æœæ•°ç»„ä¸­",
      "è¿”å›ç»“æœæ•°ç»„"
    ],
    "timeComplexity": "O(n+m)",
    "spaceComplexity": "O(min(n,m))",
    "code": "function arrayIntersection(arr1: any[], arr2: any[]): any[] {\n  const set = new Set(arr1);\n  return arr2.filter(item => set.has(item));\n}"
  },
  {
    "id": "union",
    "title": "æ•°ç»„å¹¶é›†",
    "description": "è·å–ä¸¤ä¸ªæ•°ç»„çš„å¹¶é›†",
    "icon": "âˆª",
    "category": "set",
    "difficulty": 1,
    "thinking": "åˆ©ç”¨setå»é‡åˆå¹¶åçš„ä¸¤ä¸ªæ•°ç»„",
    "steps": ["åˆ©ç”¨setå»é‡åˆå¹¶åçš„ä¸¤ä¸ªæ•°ç»„", "è¿”å›ç»“æœæ•°ç»„"],
    "timeComplexity": "O(n+m)",
    "spaceComplexity": "O(n+m)",
    "code": "function arrayUnion(arr1: any[], arr2: any[]): any[] {\n  return [...new Set([...arr1, ...arr2])];\n}"
  },
  {
    "id": "difference",
    "title": "æ•°ç»„å·®é›†",
    "description": "è·å–ä¸¤ä¸ªæ•°ç»„çš„å·®é›†(A-B)",
    "icon": "âˆ’",
    "category": "set",
    "difficulty": 1,
    "thinking": "æ¯”è¾ƒä¸¤ä¸ªæ•°ç»„çš„å¤§å°,å¤§çš„æ•°ç»„éå†åŒæ—¶æ¯”è¾ƒset(å°çš„æ•°ç»„)ä¸­æ˜¯å¦åŒ…å«è¯¥å…ƒç´ ,æ·»åŠ åˆ°ç»“æœæ•°ç»„ä¸­",
    "steps": [
      "æ¯”è¾ƒä¸¤ä¸ªæ•°ç»„çš„å¤§å°",
      "å¤§çš„æ•°ç»„éå†åŒæ—¶æ¯”è¾ƒset(å°çš„æ•°ç»„)ä¸­æ˜¯å¦åŒ…å«è¯¥å…ƒç´ ,æ·»åŠ åˆ°ç»“æœæ•°ç»„ä¸­",
      "è¿”å›ç»“æœæ•°ç»„"
    ],
    "timeComplexity": "O(n+m)",
    "spaceComplexity": "O(n)",
    "code": "function arrayDifference(arr1: any[], arr2: any[]): any[] {\n  const  largeArr  =  arr1.length > arr2.length ? arr1 : arr2;\n  const set = new Set(arr1.length > arr2.length ? arr2 : arr1);\n  return largeArr.filter(item => !set.has(item));\n}"
  },
  {
    "id": "symmetric",
    "title": "æ•°ç»„å¯¹ç§°å·®",
    "description": "è·å–ä¸¤ä¸ªæ•°ç»„çš„å¯¹ç§°å·®é›†",
    "icon": "âˆ†",
    "category": "set",
    "difficulty": 1,
    "thinking": "åˆ©ç”¨å·®é›†,ç„¶ååˆå¹¶ä¸¤ä¸ªå·®é›†",
    "steps": ["åˆ©ç”¨å·®é›†,ç„¶ååˆå¹¶ä¸¤ä¸ªå·®é›†", "è¿”å›ç»“æœæ•°ç»„"],
    "timeComplexity": "O(n+m)",
    "spaceComplexity": "O(n+m)",
    "code": "function symmetricDifference(arr1: any[], arr2: any[]): any[] {\n  const diff1 = arrayDifference(arr1, arr2);\n  const diff2 = arrayDifference(arr2, arr1);\n  return [...diff1, ...diff2];\n}"
  },
  {
    "id": "group",
    "title": "å°†æ•°ç»„åˆ†ä¸ºä¸‰ç»„",
    "description": "å°†æ•°ç»„åˆ†ä¸ºä¸‰ç»„,æ¯ç»„çš„å’Œå·®ä¸å¤šç›¸ç­‰,è¿”å›ä¸‰ç»„",
    "icon": "ğŸ”¢",
    "difficulty": 2,
    "thinking": "æ’åºå,ä»å¤§åˆ°å°,æ¯æ¬¡æŠŠæœ€å¤§çš„å€¼ç»™åˆ°å’Œæœ€å°çš„æ•°ç»„ä¸­",
    "steps": ["æ’åºå,ä»å¤§åˆ°å°,æ¯æ¬¡æŠŠæœ€å¤§çš„å€¼ç»™åˆ°å’Œæœ€å°çš„æ•°ç»„ä¸­", "è¿”å›ä¸‰ç»„"],
    "category": "group",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function  oneToThreeArr(arr){\n let res = [{sum: 0, arr: []}, {sum: 0, arr: []}, {sum: 0, arr: []}]\n arr = arr.slice().sort((a,b) => b - a);\n arr.map(item => {\n let min = res.sort((a,b) => a.sum - b.sum)[0];\n min.sum += item;\n min.arr.push(item);\n })\n return res;\n}"
  },
  {
    "id": "flatten",
    "title": "æ•°ç»„æ‰å¹³åŒ–",
    "description": "å°†å¤šå±‚åµŒå¥—æ•°ç»„æ‰å¹³åŒ–ä¸ºä¸€ç»´æ•°ç»„",
    "icon": "ğŸ“",
    "category": "transform",
    "difficulty": 1,
    "thinking": "åˆ©ç”¨reduceæ–¹æ³•å’Œé€’å½’,å°†æ•°ç»„æ‰å¹³åŒ–",
    "steps": ["åˆ©ç”¨reduceæ–¹æ³•å’Œé€’å½’,å°†æ•°ç»„æ‰å¹³åŒ–", "è¿”å›ç»“æœæ•°ç»„"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function flattenArray(arr: any[]): any[] {\n  return arr.reduce((flat, item) =>\n    flat.concat(Array.isArray(item) ?\n      flattenArray(item) : item\n    ), []\n  );\n}"
  },
  {
    "id": "chunk",
    "title": "æ•°ç»„åˆ†å—",
    "description": "å°†æ•°ç»„åˆ†å‰²ä¸ºæŒ‡å®šå¤§å°çš„å—",
    "icon": "ğŸ”¢",
    "category": "group",
    "difficulty": 1,
    "thinking": "åˆ©ç”¨sliceæ–¹æ³•,å°†æ•°ç»„åˆ†å‰²ä¸ºæŒ‡å®šå¤§å°çš„å—",
    "steps": ["åˆ©ç”¨sliceæ–¹æ³•,å°†æ•°ç»„åˆ†å‰²ä¸ºæŒ‡å®šå¤§å°çš„å—", "è¿”å›ç»“æœæ•°ç»„"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function chunkArray(arr: any[], size: number): any[][] {\n  const chunks = [];\n  for (let i = 0; i < arr.length; i += size) {\n    chunks.push(arr.slice(i, i + size));\n  }\n  return chunks;\n}"
  },
  {
    "id": "rotate",
    "title": "æ•°ç»„æ—‹è½¬",
    "description": "å°†æ•°ç»„å‘å³æ—‹è½¬æŒ‡å®šä½ç½®",
    "icon": "ğŸ”„",
    "category": "transform",
    "difficulty": 1,
    "thinking": "åˆ©ç”¨sliceæ–¹æ³•,å°†æ•°ç»„å‘å³æ—‹è½¬æŒ‡å®šä½ç½®",
    "steps": ["åˆ©ç”¨sliceæ–¹æ³•,å°†æ•°ç»„å‘å³æ—‹è½¬æŒ‡å®šä½ç½®", "è¿”å›ç»“æœæ•°ç»„"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function rotateArray(arr: any[], k: number): any[] {\n  const rotations = k % arr.length;\n  return [\n    ...arr.slice(-rotations),\n    ...arr.slice(0, arr.length - rotations)\n  ];\n}"
  },
  {
    "id": "partition",
    "title": "æ•°ç»„åˆ†åŒº",
    "description": "æ ¹æ®æ¡ä»¶å°†æ•°ç»„åˆ’åˆ†ä¸ºä¸¤éƒ¨åˆ†",
    "icon": "âš–ï¸",
    "category": "group",
    "difficulty": 1,
    "thinking": "åˆ©ç”¨sliceæ–¹æ³•,å°†æ•°ç»„å‘å³æ—‹è½¬æŒ‡å®šä½ç½®",
    "steps": ["åˆ©ç”¨sliceæ–¹æ³•,å°†æ•°ç»„å‘å³æ—‹è½¬æŒ‡å®šä½ç½®", "è¿”å›ç»“æœæ•°ç»„"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function partitionArray(arr: any[], predicate: (item: any) => boolean): any[][] {\n  const trueArr = [];\n  const falseArr = [];\n  arr.forEach(item =>\n    predicate(item) ? trueArr.push(item) : falseArr.push(item)\n  );\n  return [trueArr, falseArr];\n}"
  },
  {
    "id": "zip",
    "title": "æ•°ç»„zipæ“ä½œ",
    "description": "å°†å¤šä¸ªæ•°ç»„åˆå¹¶ä¸ºä¸€ä¸ªå…ƒç»„æ•°ç»„",
    "icon": "ğŸ¤",
    "category": "transform",
    "difficulty": 2,
    "thinking": "åˆ©ç”¨sliceæ–¹æ³•,å°†æ•°ç»„å‘å³æ—‹è½¬æŒ‡å®šä½ç½®",
    "steps": ["åˆ©ç”¨sliceæ–¹æ³•,å°†æ•°ç»„å‘å³æ—‹è½¬æŒ‡å®šä½ç½®", "è¿”å›ç»“æœæ•°ç»„"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function zipArrays(...arrays: any[][]): any[][] {\n  const maxLength = Math.max(...arrays.map(arr => arr.length));\n  return Array.from({ length: maxLength }, (_, i) =>\n    arrays.map(arr => arr[i])\n  );\n}"
  },
  {
    "id": "prefix-sum",
    "title": "å‰ç¼€å’Œæ•°ç»„",
    "description": "è®¡ç®—æ•°ç»„çš„å‰ç¼€å’Œåºåˆ—",
    "icon": "ğŸ“¶",
    "category": "math",
    "difficulty": 1,
    "thinking": "è¿­ä»£è®¡ç®—ç´¯è®¡å’Œå¹¶å­˜å‚¨åœ¨æ–°æ•°ç»„ä¸­",
    "steps": ["åˆ›å»ºé•¿åº¦ç›¸åŒçš„æ–°æ•°ç»„", "é¦–å…ƒç´ ä¸åŸæ•°ç»„ç›¸åŒ", "åç»­å…ƒç´ ç­‰äºå‰ä¸€ä¸ªå‰ç¼€å’ŒåŠ å½“å‰å…ƒç´ å€¼"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function prefixSum(arr: number[]): number[] {\n  const result = new Array(arr.length);\n  result[0] = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    result[i] = result[i - 1] + arr[i];\n  }\n  return result;\n}"
  },
  {
    "id": "spiral",
    "title": "èºæ—‹éå†",
    "description": "èºæ—‹é¡ºåºéå†äºŒç»´æ•°ç»„",
    "icon": "ğŸŒ€",
    "category": "traversal",
    "difficulty": 3,
    "thinking": "ä½¿ç”¨å››æŒ‡é’ˆå®šä¹‰è¾¹ç•Œå¹¶é€å±‚å‘å†…æ”¶ç¼©",
    "steps": [
      "åˆå§‹åŒ–ä¸Šä¸‹å·¦å³å››ä¸ªè¾¹ç•ŒæŒ‡é’ˆ",
      "æŒ‰å³â†’ä¸‹â†’å·¦â†’ä¸Šé¡ºåºéå†",
      "æ¯å®Œæˆä¸€ä¸ªæ–¹å‘æ”¶ç¼©å¯¹åº”è¾¹ç•Œ",
      "å½“è¾¹ç•Œäº¤é”™æ—¶åœæ­¢"
    ],
    "timeComplexity": "O(n*m)",
    "spaceComplexity": "O(1)",
    "code": "function spiralOrder(matrix: number[][]): number[] {\n  if (!matrix.length) return [];\n  const result = [];\n  let top = 0, bottom = matrix.length - 1;\n  let left = 0, right = matrix[0].length - 1;\n  \n  while (top <= bottom && left <= right) {\n    for (let i = left; i <= right; i++) result.push(matrix[top][i]);\n    top++;\n    \n    for (let i = top; i <= bottom; i++) result.push(matrix[i][right]);\n    right--;\n    \n    if (top <= bottom) {\n      for (let i = right; i >= left; i--) result.push(matrix[bottom][i]);\n      bottom--;\n    }\n    \n    if (left <= right) {\n      for (let i = bottom; i >= top; i--) result.push(matrix[i][left]);\n      left++;\n    }\n  }\n  return result;\n}"
  },
  {
    "id": "max-subarray",
    "title": "æœ€å¤§å­æ•°ç»„å’Œ",
    "description": "å¯»æ‰¾è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œ",
    "icon": "ğŸ“ˆ",
    "category": "math",
    "difficulty": 2,
    "thinking": "Kadaneç®—æ³•åŠ¨æ€æ›´æ–°å½“å‰å’Œä¸æœ€å¤§å’Œ",
    "steps": [
      "åˆå§‹åŒ–å½“å‰å’Œä¸æœ€å¤§å’Œä¸ºç¬¬ä¸€ä¸ªå…ƒç´ ",
      "éå†æ•°ç»„æ›´æ–°å½“å‰å’Œï¼ˆå–å½“å‰å…ƒç´ æˆ–ä¸å‰é¢åˆå¹¶ï¼‰",
      "æ¯”è¾ƒæ›´æ–°å…¨å±€æœ€å¤§å’Œ"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function maxSubarraySum(arr: number[]): number {\n  let maxSum = arr[0];\n  let currentSum = arr[0];\n  \n  for (let i = 1; i < arr.length; i++) {\n    currentSum = Math.max(arr[i], currentSum + arr[i]);\n    maxSum = Math.max(maxSum, currentSum);\n  }\n  return maxSum;\n}"
  },
  {
    "id": "mode",
    "title": "æ•°ç»„ä¼—æ•°",
    "description": "æ‰¾å‡ºæ‰€æœ‰å‡ºç°é¢‘ç‡æœ€é«˜çš„å…ƒç´ ",
    "icon": "ğŸ”¢",
    "category": "count",
    "difficulty": 2,
    "thinking": "å…ˆç»Ÿè®¡é¢‘ç‡å†ç­›é€‰å‡ºæ‰€æœ‰æœ€å¤§é¢‘ç‡å…ƒç´ ",
    "steps": ["ä½¿ç”¨Mapç»Ÿè®¡å…ƒç´ é¢‘ç‡", "è®°å½•æœ€é«˜é¢‘ç‡å€¼", "ç­›é€‰å‡ºæ‰€æœ‰ç­‰äºæœ€é«˜é¢‘ç‡çš„å…ƒç´ "],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function findMode(arr: any[]): any[] {\n  const freq = new Map();\n  let maxFreq = 0;\n  \n  for (const item of arr) {\n    const count = (freq.get(item) || 0) + 1;\n    freq.set(item, count);\n    maxFreq = Math.max(maxFreq, count);\n  }\n  \n  return Array.from(freq.entries())\n    .filter(([_, count]) => count === maxFreq)\n    .map(([item]) => item);\n}"
  },
  {
    "id": "transpose",
    "title": "çŸ©é˜µè½¬ç½®",
    "description": "äºŒç»´æ•°ç»„è¡Œåˆ—äº’æ¢",
    "icon": "ğŸ”„",
    "category": "transform",
    "difficulty": 2,
    "thinking": "é€šè¿‡è¡Œåˆ—ç´¢å¼•äº’æ¢åˆ›å»ºæ–°çŸ©é˜µ",
    "steps": ["åˆ›å»ºæ–°æ•°ç»„ï¼ˆåˆ—æ•°å˜è¡Œæ•°ï¼‰", "åŒå±‚å¾ªç¯äº¤æ¢è¡Œåˆ—ç´¢å¼•"],
    "timeComplexity": "O(n*m)",
    "spaceComplexity": "O(n*m)",
    "code": "function transpose(matrix: any[][]): any[][] {\n  return matrix[0].map((_, colIndex) =>\n    matrix.map(row => row[colIndex])\n  );\n}"
  },
  {
    "id": "deep-clone",
    "title": "æ·±åº¦å…‹éš†æ•°ç»„",
    "description": "é€’å½’å…‹éš†åµŒå¥—æ•°ç»„ç»“æ„",
    "icon": "ğŸ“‹",
    "category": "creation",
    "difficulty": 2,
    "thinking": "é€’å½’å¤„ç†åµŒå¥—æ•°ç»„ç»“æ„",
    "steps": [
      "åŸºæœ¬ç±»å‹ç›´æ¥è¿”å›",
      "æ•°ç»„ç±»å‹é€’å½’å…‹éš†æ¯ä¸ªå…ƒç´ ",
      "å¯¹è±¡ç±»å‹å•ç‹¬å¤„ç†ï¼ˆæœ¬å‡½æ•°ä»…å¤„ç†æ•°ç»„ï¼‰"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function deepCloneArray(arr: any[]): any[] {\n  return arr.map(item => \n    Array.isArray(item) ? deepCloneArray(item) : item\n  );\n}"
  },
  {
    "id": "group-by",
    "title": "æ¡ä»¶åˆ†ç»„",
    "description": "æŒ‰å‡½æ•°è¿”å›å€¼åˆ†ç»„æ•°ç»„å…ƒç´ ",
    "icon": "ğŸ—‚ï¸",
    "category": "group",
    "difficulty": 2,
    "thinking": "ä½¿ç”¨MapåŠ¨æ€åˆ›å»ºåˆ†ç»„",
    "steps": ["éå†æ•°ç»„è®¡ç®—åˆ†ç»„é”®", "æŒ‰é”®å€¼å­˜å‚¨åˆ°Mapä¸­", "è½¬æ¢Mapä¸ºåˆ†ç»„å¯¹è±¡"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function groupBy(arr: any[], fn: (item: any) => string) {\n  return arr.reduce((groups, item) => {\n    const key = fn(item);\n    if (!groups[key]) groups[key] = [];\n    groups[key].push(item);\n    return groups;\n  }, {});\n}"
  },
  {
    "id": "permutations",
    "title": "æ•°ç»„æ’åˆ—",
    "description": "ç”Ÿæˆæ•°ç»„å…ƒç´ çš„æ‰€æœ‰æ’åˆ—",
    "icon": "ğŸ”„",
    "category": "count",
    "difficulty": 3,
    "thinking": "é€’å½’äº¤æ¢å…ƒç´ ä½ç½®ç”Ÿæˆå…¨æ’åˆ—",
    "steps": [
      "åŸºçº¿æ¡ä»¶ï¼šå•å…ƒç´ æ•°ç»„ç›´æ¥è¿”å›",
      "é€’å½’å–å‡ºé¦–å…ƒç´ ç”Ÿæˆå­æ’åˆ—",
      "å°†é¦–å…ƒç´ æ’å…¥å­æ’åˆ—çš„æ‰€æœ‰ä½ç½®"
    ],
    "timeComplexity": "O(n!)",
    "spaceComplexity": "O(n!)",
    "code": "function permutations(arr: any[]): any[][] {\n  if (arr.length <= 1) return [arr];\n  const [first, ...rest] = arr;\n  return permutations(rest).flatMap(perm => \n    Array.from({length: perm.length + 1}, (_, i) =>\n      [...perm.slice(0, i), first, ...perm.slice(i)]\n    )\n  );\n}"
  },
  {
    "id": "diff-array",
    "title": "å·®åˆ†æ•°ç»„",
    "description": "æ„å»ºå¿«é€ŸåŒºé—´æ“ä½œçš„å·®åˆ†æ•°ç»„",
    "icon": "ğŸ“Š",
    "category": "math",
    "difficulty": 2,
    "thinking": "åˆ©ç”¨ç›¸é‚»å…ƒç´ çš„å·®å€¼æ„é€ è¾…åŠ©æ•°ç»„",
    "steps": [
      "é¦–å…ƒç´ ä¸åŸæ•°ç»„ç›¸åŒ",
      "åç»­å…ƒç´ ç­‰äºå½“å‰åŸæ•°ç»„å€¼å‡å‰ä¸€ä¸ªåŸæ•°ç»„å€¼",
      "é€šè¿‡å‰ç¼€å’Œå¯æ¢å¤åŸæ•°ç»„"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function createDiffArray(arr: number[]): number[] {\n  const diff = new Array(arr.length);\n  diff[0] = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    diff[i] = arr[i] - arr[i - 1];\n  }\n  return diff;\n}"
  },
  {
    "id": "dot-product",
    "title": "ç‚¹ç§¯è¿ç®—",
    "description": "è®¡ç®—ä¸¤ä¸ªå‘é‡çš„ç‚¹ç§¯",
    "icon": "â¨€",
    "category": "math",
    "difficulty": 1,
    "thinking": "å¯¹åº”ä½ç½®ç›¸ä¹˜åæ±‚å’Œ",
    "steps": ["éªŒè¯å‘é‡é•¿åº¦ç›¸åŒ", "é€å…ƒç´ ç›¸ä¹˜å¹¶ç´¯åŠ ç»“æœ"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function dotProduct(vecA: number[], vecB: number[]): number {\n  if (vecA.length !== vecB.length) throw new Error('Vectors must have same length');\n  return vecA.reduce((sum, val, i) => sum + val * vecB[i], 0);\n}"
  },
  {
    "id": "fisher-yates",
    "title": "Fisher-Yatesæ´—ç‰Œ",
    "description": "å‡åŒ€éšæœºæ‰“ä¹±æ•°ç»„å…ƒç´ çš„ç®—æ³•",
    "icon": "ğŸ´",
    "category": "transform",
    "difficulty": 2,
    "thinking": "é€†å‘éå†å¹¶éšæœºäº¤æ¢å…ƒç´ ä½ç½®",
    "steps": ["ä»åå‘å‰éå†æ•°ç»„", "éšæœºé€‰æ‹©å½“å‰ä½ç½®ä¹‹å‰çš„ç´¢å¼•", "äº¤æ¢å½“å‰å…ƒç´ ä¸éšæœºé€‰ä¸­å…ƒç´ "],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function fisherYatesShuffle(arr: any[]): any[] {\n  for (let i = arr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [arr[i], arr[j]] = [arr[j], arr[i]];\n  }\n  return arr;\n}"
  },
  {
    "id": "array-equal",
    "title": "æ•°ç»„ç›¸ç­‰æ€§",
    "description": "æ·±åº¦æ¯”è¾ƒä¸¤ä¸ªæ•°ç»„æ˜¯å¦å®Œå…¨ç›¸åŒ",
    "icon": "âš–ï¸",
    "category": "comparison",
    "difficulty": 2,
    "thinking": "é€’å½’æ¯”è¾ƒåµŒå¥—ç»“æ„å’Œå…ƒç´ å€¼",
    "steps": ["é•¿åº¦ä¸åŒç›´æ¥è¿”å›false", "é€’å½’æ¯”è¾ƒåµŒå¥—æ•°ç»„", "ä¸¥æ ¼æ¯”è¾ƒåŸºæœ¬ç±»å‹å€¼"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function arraysEqual(a: any[], b: any[]): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (Array.isArray(a[i]) && Array.isArray(b[i])) {\n      if (!arraysEqual(a[i], b[i])) return false;\n    } else if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}"
  },
  {
    "id": "binary-search",
    "title": "äºŒåˆ†æŸ¥æ‰¾",
    "description": "åœ¨æœ‰åºæ•°ç»„ä¸­æŸ¥æ‰¾ç›®æ ‡å…ƒç´ çš„ä½ç½®",
    "icon": "ğŸ”",
    "category": "search",
    "difficulty": 2,
    "thinking": "é€šè¿‡ä¸æ–­ç¼©å°æœç´¢èŒƒå›´å®šä½ç›®æ ‡å…ƒç´ ",
    "steps": [
      "åˆå§‹åŒ–å·¦å³æŒ‡é’ˆæŒ‡å‘æ•°ç»„é¦–å°¾",
      "è®¡ç®—ä¸­é—´ç´¢å¼•å¹¶ä¸ç›®æ ‡æ¯”è¾ƒ",
      "æ ¹æ®æ¯”è¾ƒç»“æœç§»åŠ¨å·¦å³æŒ‡é’ˆ",
      "æ‰¾åˆ°è¿”å›ç´¢å¼•ï¼Œå¦åˆ™è¿”å›-1"
    ],
    "timeComplexity": "O(log n)",
    "spaceComplexity": "O(1)",
    "code": "function binarySearch(arr: number[], target: number): number {\n  let left = 0;\n  let right = arr.length - 1;\n  \n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) return mid;\n    if (arr[mid] < target) left = mid + 1;\n    else right = mid - 1;\n  }\n  \n  return -1;\n}"
  },
  {
    "id": "range",
    "title": "ç”Ÿæˆæ•°å€¼èŒƒå›´æ•°ç»„",
    "description": "ç”ŸæˆæŒ‡å®šèŒƒå›´å†…çš„æ•°å€¼æ•°ç»„",
    "icon": "â†”ï¸",
    "category": "creation",
    "difficulty": 1,
    "thinking": "ä½¿ç”¨å¾ªç¯æˆ–Array.fromç”Ÿæˆè¿ç»­æ•°å€¼åºåˆ—",
    "steps": ["è®¡ç®—æ•°ç»„é•¿åº¦", "ç”Ÿæˆä»èµ·å§‹å€¼åˆ°ç»“æŸå€¼çš„åºåˆ—", "è¿”å›ç»“æœæ•°ç»„"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function generateRange(start: number, end: number, step = 1): number[] {\n  const length = Math.floor((end - start) / step) + 1;\n  return Array.from({ length }, (_, i) => start + i * step);\n}"
  },
  {
    "id": "fill-pattern",
    "title": "æ¨¡å¼å¡«å……æ•°ç»„",
    "description": "ä½¿ç”¨æŒ‡å®šæ¨¡å¼å¡«å……æ•°ç»„",
    "icon": "ğŸ”„",
    "category": "creation",
    "difficulty": 1,
    "thinking": "å¾ªç¯åº”ç”¨æ¨¡å¼åºåˆ—å¡«å……æ•°ç»„",
    "steps": ["æ ¹æ®æ¨¡å¼é•¿åº¦åˆ›å»ºå¡«å……å‡½æ•°", "å¾ªç¯åº”ç”¨æ¨¡å¼åˆ°æ¯ä¸ªä½ç½®", "è¿”å›å¡«å……åçš„æ•°ç»„"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function fillWithPattern(length: number, pattern: any[]): any[] {\n  return Array.from({ length }, (_, i) => pattern[i % pattern.length]);\n}"
  },
  {
    "id": "unique",
    "title": "æ•°ç»„å”¯ä¸€åŒ–",
    "description": "ç§»é™¤æ•°ç»„ä¸­é‡å¤çš„å…ƒç´ ",
    "icon": "âœ¨",
    "category": "transform",
    "difficulty": 1,
    "thinking": "åˆ©ç”¨Setæ•°æ®ç»“æ„è‡ªåŠ¨å»é‡",
    "steps": ["åˆ›å»ºSetå®ä¾‹ä¼ å…¥æ•°ç»„", "å°†Setè½¬æ¢å›æ•°ç»„", "è¿”å›å»é‡åçš„æ•°ç»„"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function uniqueArray(arr: any[]): any[] {\n  return [...new Set(arr)];\n}"
  },
  {
    "id": "reverse",
    "title": "æ•°ç»„åè½¬",
    "description": "åè½¬æ•°ç»„å…ƒç´ çš„é¡ºåº",
    "icon": "ğŸ”„",
    "category": "transform",
    "difficulty": 1,
    "thinking": "åŒæŒ‡é’ˆä»ä¸¤ç«¯å‘ä¸­é—´äº¤æ¢å…ƒç´ ",
    "steps": ["åˆå§‹åŒ–å·¦å³æŒ‡é’ˆ", "äº¤æ¢æŒ‡é’ˆä½ç½®å…ƒç´ å¹¶å‘ä¸­é—´ç§»åŠ¨", "è¿”å›åè½¬åçš„æ•°ç»„"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function reverseArray(arr: any[]): any[] {\n  const result = [...arr];\n  let left = 0, right = result.length - 1;\n  \n  while (left < right) {\n    [result[left], result[right]] = [result[right], result[left]];\n    left++;\n    right--;\n  }\n  \n  return result;\n}"
  },
  {
    "id": "move-zeros",
    "title": "ç§»åŠ¨é›¶å…ƒç´ ",
    "description": "å°†æ‰€æœ‰0ç§»åŠ¨åˆ°æ•°ç»„æœ«å°¾å¹¶ä¿æŒéé›¶å…ƒç´ é¡ºåº",
    "icon": "â©",
    "category": "transform",
    "difficulty": 1,
    "thinking": "åŒæŒ‡é’ˆæ³•ï¼šæ…¢æŒ‡é’ˆè®°å½•éé›¶ä½ç½®ï¼Œå¿«æŒ‡é’ˆéå†æ•°ç»„",
    "steps": [
      "åˆå§‹åŒ–æ…¢æŒ‡é’ˆä¸º0",
      "å¿«æŒ‡é’ˆéå†æ•°ç»„ï¼Œå‘ç°éé›¶å…ƒç´ åˆ™å¤åˆ¶åˆ°æ…¢æŒ‡é’ˆä½ç½®",
      "æ…¢æŒ‡é’ˆåç§»",
      "å‰©ä½™ä½ç½®å¡«å……0"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function moveZeros(arr: number[]): number[] {\n  let nonZeroIndex = 0;\n  \n  // ç§»åŠ¨éé›¶å…ƒç´ \n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] !== 0) {\n      arr[nonZeroIndex++] = arr[i];\n    }\n  }\n  \n  // å‰©ä½™ä½ç½®å¡«0\n  for (let i = nonZeroIndex; i < arr.length; i++) {\n    arr[i] = 0;\n  }\n  \n  return arr;\n}"
  },
  {
    "id": "window-sum",
    "title": "æ»‘åŠ¨çª—å£æ±‚å’Œ",
    "description": "è®¡ç®—å›ºå®šå¤§å°çª—å£å†…çš„å…ƒç´ å’Œ",
    "icon": "ğŸªŸ",
    "category": "math",
    "difficulty": 2,
    "thinking": "ä½¿ç”¨æ»‘åŠ¨çª—å£æŠ€æœ¯é¿å…é‡å¤è®¡ç®—",
    "steps": ["è®¡ç®—åˆå§‹çª—å£å’Œ", "æ»‘åŠ¨çª—å£ï¼šå‡å»ç¦»å¼€å…ƒç´ ï¼ŒåŠ ä¸Šæ–°è¿›å…¥å…ƒç´ ", "è®°å½•æ¯ä¸ªçª—å£çš„å’Œ"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function slidingWindowSum(arr: number[], k: number): number[] {\n  const result = [];\n  let windowSum = 0;\n  \n  // è®¡ç®—åˆå§‹çª—å£å’Œ\n  for (let i = 0; i < k; i++) {\n    windowSum += arr[i];\n  }\n  result.push(windowSum);\n  \n  // æ»‘åŠ¨çª—å£\n  for (let i = k; i < arr.length; i++) {\n    windowSum = windowSum - arr[i - k] + arr[i];\n    result.push(windowSum);\n  }\n  \n  return result;\n}"
  },
  {
    "id": "compress",
    "title": "æ•°ç»„å‹ç¼©",
    "description": "ç§»é™¤è¿ç»­é‡å¤å…ƒç´ ",
    "icon": "ğŸ—œï¸",
    "category": "transform",
    "difficulty": 1,
    "thinking": "éå†æ•°ç»„åªä¿ç•™ä¸å‰ä¸€ä¸ªä¸åŒçš„å…ƒç´ ",
    "steps": [
      "åˆ›å»ºç»“æœæ•°ç»„",
      "éå†æ•°ç»„ï¼Œæ¯”è¾ƒå½“å‰å…ƒç´ ä¸å‰ä¸€ä¸ª",
      "åªæ·»åŠ ä¸å‰ä¸€ä¸ªä¸åŒçš„å…ƒç´ ",
      "è¿”å›å‹ç¼©åçš„æ•°ç»„"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function compressArray(arr: any[]): any[] {\n  return arr.filter((item, index) => index === 0 || item !== arr[index - 1]);\n}"
  },
  {
    "id": "run-length-encoding",
    "title": "æ¸¸ç¨‹ç¼–ç ",
    "description": "å°†è¿ç»­é‡å¤å…ƒç´ ç¼–ç ä¸º[å…ƒç´ , æ¬¡æ•°]",
    "icon": "ğŸšï¸",
    "category": "transform",
    "difficulty": 2,
    "thinking": "éå†æ•°ç»„ç»Ÿè®¡è¿ç»­ç›¸åŒå…ƒç´ çš„ä¸ªæ•°",
    "steps": [
      "åˆå§‹åŒ–ç»“æœæ•°ç»„å’Œå½“å‰è®¡æ•°",
      "éå†æ•°ç»„æ¯”è¾ƒå½“å‰ä¸å‰ä¸€ä¸ªå…ƒç´ ",
      "ç›¸åŒåˆ™è®¡æ•°å¢åŠ ï¼Œä¸åŒåˆ™è®°å½•å‰ä¸€ç»„",
      "è¿”å›ç¼–ç ç»“æœ"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function runLengthEncoding(arr: any[]): [any, number][] {\n  if (arr.length === 0) return [];\n  \n  const result: [any, number][] = [];\n  let current = arr[0];\n  let count = 1;\n  \n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] === current) {\n      count++;\n    } else {\n      result.push([current, count]);\n      current = arr[i];\n      count = 1;\n    }\n  }\n  \n  result.push([current, count]);\n  return result;\n}"
  },
  {
    "id": "fill-array",
    "title": "æ•°ç»„å¡«å……",
    "description": "ç”¨ç”Ÿæˆå™¨å‡½æ•°å¡«å……æ•°ç»„",
    "icon": "ğŸ–Œï¸",
    "category": "creation",
    "difficulty": 2,
    "thinking": "ä½¿ç”¨ç”Ÿæˆå™¨å‡½æ•°åŠ¨æ€åˆ›å»ºæ•°ç»„å…ƒç´ ",
    "steps": ["å®šä¹‰å…ƒç´ ç”Ÿæˆå™¨å‡½æ•°", "å¾ªç¯ç”ŸæˆæŒ‡å®šæ•°é‡çš„å…ƒç´ ", "è¿”å›å¡«å……åçš„æ•°ç»„"],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function fillArray<T>(length: number, generator: (index: number) => T): T[] {\n  return Array.from({ length }, (_, i) => generator(i));\n}"
  },
  {
    "id": "find-pairs",
    "title": "æŸ¥æ‰¾å’Œä¸ºç›®æ ‡å€¼çš„å…ƒç´ å¯¹",
    "description": "æŸ¥æ‰¾æ‰€æœ‰å’Œä¸ºæŒ‡å®šç›®æ ‡å€¼çš„å…ƒç´ å¯¹",
    "icon": "ğŸ‘«",
    "category": "search",
    "difficulty": 2,
    "thinking": "ä½¿ç”¨å“ˆå¸Œè¡¨è®°å½•å…ƒç´ ç´¢å¼•",
    "steps": [
      "åˆ›å»ºMapå­˜å‚¨å…ƒç´ ç´¢å¼•",
      "éå†æ•°ç»„ï¼Œè®¡ç®—ç›®æ ‡å·®å€¼",
      "åœ¨Mapä¸­æŸ¥æ‰¾å·®å€¼ï¼Œæ‰¾åˆ°åˆ™è®°å½•å…ƒç´ å¯¹",
      "è¿”å›æ‰€æœ‰ç¬¦åˆæ¡ä»¶çš„å…ƒç´ å¯¹"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function findPairs(arr: number[], target: number): [number, number][] {\n  const map = new Map<number, number>();\n  const pairs: [number, number][] = [];\n  \n  for (let i = 0; i < arr.length; i++) {\n    const complement = target - arr[i];\n    \n    if (map.has(complement)) {\n      pairs.push([complement, arr[i]]);\n    }\n    \n    map.set(arr[i], i);\n  }\n  \n  return pairs;\n}"
  },
  {
    "id": "array-diff",
    "title": "æ•°ç»„å·®å¼‚",
    "description": "æ¯”è¾ƒä¸¤ä¸ªæ•°ç»„çš„å·®å¼‚",
    "icon": "ğŸ”",
    "category": "search",
    "difficulty": 2,
    "thinking": "æ‰¾å‡ºæ–°å¢ã€åˆ é™¤å’Œæ›´æ–°çš„å…ƒç´ ",
    "steps": [
      "åˆ›å»ºMapå­˜å‚¨æ—§æ•°ç»„ç´¢å¼•",
      "éå†æ–°æ•°ç»„ï¼Œè¯†åˆ«æ›´æ–°å’Œæ–°å¢",
      "æ£€æŸ¥æ—§æ•°ç»„æœªè¢«ä½¿ç”¨çš„å…ƒç´ ä½œä¸ºåˆ é™¤",
      "è¿”å›å·®å¼‚ç»“æœ"
    ],
    "timeComplexity": "O(n+m)",
    "spaceComplexity": "O(n+m)",
    "code": "function arrayDiff<T>(oldArr: T[], newArr: T[]): {\n  added: T[],\n  removed: T[],\n  updated: T[]\n} {\n  const oldMap = new Map<T, number>();\n  oldArr.forEach((item, index) => oldMap.set(item, index));\n  \n  const added: T[] = [];\n  const updated: T[] = [];\n  const newSet = new Set(newArr);\n  \n  newArr.forEach((item, index) => {\n    if (!oldMap.has(item)) {\n      added.push(item);\n    } else if (oldMap.get(item) !== index) {\n      updated.push(item);\n    }\n  });\n  \n  const removed = oldArr.filter(item => !newSet.has(item));\n  \n  return { added, removed, updated };\n}"
  }
]
