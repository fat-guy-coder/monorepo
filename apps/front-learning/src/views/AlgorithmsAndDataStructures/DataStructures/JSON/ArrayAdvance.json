[
  {
    "id": "flatten",
    "title": "æ•°ç»„æ‰å¹³åŒ–",
    "type": "å˜æ¢",
    "description": "å°†å¤šå±‚åµŒå¥—æ•°ç»„æ‰å¹³åŒ–ä¸ºä¸€ç»´æ•°ç»„",
    "steps": ["1. ä½¿ç”¨reduceæ–¹æ³•ï¼Œå°†æ•°ç»„åˆå¹¶", "2. ä½¿ç”¨é€’å½’ï¼Œå°†æ•°ç»„æ‰å¹³åŒ–"],
    "icon": "ğŸ“",
    "category": "advanced",
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function flattenArray(arr: any[]): any[] {\n  return arr.reduce((flat, item) =>\n    flat.concat(Array.isArray(item) ?\n      flattenArray(item) : item\n  ), []);\n}"
  },
  {
    "id": "rotate",
    "title": "æ•°ç»„æ—‹è½¬",
    "type": "å˜æ¢",
    "description": "å°†æ•°ç»„å‘å³æ—‹è½¬æŒ‡å®šä½ç½®",
    "icon": "ğŸ”„",
    "category": "advanced",
    "steps": [
      "1. è®¡ç®—å®é™…æ—‹è½¬æ¬¡æ•°ï¼ˆå–æ¨¡é¿å…æ— æ•ˆæ—‹è½¬ï¼‰",
      "2. åˆ†å‰²æ•°ç»„ä¸ºårotationsä¸ªå…ƒç´ å’Œå‰©ä½™å…ƒç´ ",
      "3. æ‹¼æ¥ä¸¤éƒ¨åˆ†å½¢æˆæ—‹è½¬åæ•°ç»„"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function rotateArray(arr: any[], k: number): any[] {\n  const rotations = k % arr.length;\n  return [\n    ...arr.slice(-rotations),\n    ...arr.slice(0, arr.length - rotations)\n  ];\n}"
  },
  {
    "id": "partition",
    "title": "æ•°ç»„åˆ†åŒº",
    "type": "åˆ†ç±»",
    "description": "æ ¹æ®æ¡ä»¶å°†æ•°ç»„åˆ’åˆ†ä¸ºä¸¤éƒ¨åˆ†",
    "icon": "âš–ï¸",
    "category": "advanced",
    "steps": [
      "1. åˆå§‹åŒ–ä¸¤ä¸ªç»“æœæ•°ç»„ï¼ˆæ»¡è¶³æ¡ä»¶/ä¸æ»¡è¶³æ¡ä»¶ï¼‰",
      "2. éå†åŸæ•°ç»„æ£€æŸ¥æ¯ä¸ªå…ƒç´ ",
      "3. æ ¹æ®æ¡ä»¶å‡½æ•°å°†å…ƒç´ åˆ†é…åˆ°å¯¹åº”æ•°ç»„"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function partitionArray(arr: any[], predicate: (item: any) => boolean): any[][] {\n  const trueArr = [];\n  const falseArr = [];\n  arr.forEach(item =>\n    predicate(item) ? trueArr.push(item) : falseArr.push(item)\n  );\n  return [trueArr, falseArr];\n}"
  },
  {
    "id": "zip",
    "title": "æ•°ç»„zipæ“ä½œ",
    "type": "å˜æ¢",
    "description": "å°†å¤šä¸ªæ•°ç»„åˆå¹¶ä¸ºä¸€ä¸ªå…ƒç»„æ•°ç»„",
    "icon": "ğŸ¤",
    "category": "advanced",
    "steps": [
      "1. è·å–æ‰€æœ‰è¾“å…¥æ•°ç»„çš„æœ€å¤§é•¿åº¦",
      "2. åˆ›å»ºæ–°æ•°ç»„ï¼ˆé•¿åº¦=æœ€å¤§é•¿åº¦ï¼‰",
      "3. ä¸ºæ¯ä¸ªä½ç½®åˆ›å»ºå…ƒç»„ï¼ˆåŒ…å«å„æ•°ç»„å½“å‰ä½ç½®å…ƒç´ ï¼‰"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function zipArrays(...arrays: any[][]): any[][] {\n  const maxLength = Math.max(...arrays.map(arr => arr.length));\n  return Array.from({ length: maxLength }, (_, i) =>\n    arrays.map(arr => arr[i])\n  );\n}"
  },
  {
    "id": "cartesian",
    "title": "ç¬›å¡å°”ç§¯",
    "type": "ç»„åˆ",
    "description": "è®¡ç®—å¤šä¸ªæ•°ç»„çš„ç¬›å¡å°”ç§¯ï¼Œç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„ç»„åˆã€‚ç¬›å¡å°”ç§¯è¡¨ç¤ºä¸¤ä¸ªé›†åˆä¸­æ‰€æœ‰å¯èƒ½çš„æœ‰åºå¯¹ã€‚",
    "icon": "âœ–ï¸",
    "category": "advanced",
    "steps": [
      "1. åˆå§‹åŒ–ä¸ºåŒ…å«ç©ºæ•°ç»„çš„æ•°ç»„",
      "2. å¯¹æ¯ä¸ªè¾“å…¥æ•°ç»„æ‰§è¡Œreduceæ“ä½œ",
      "3. å°†å½“å‰æ•°ç»„å…ƒç´ ä¸ç´¯ç§¯ç»“æœä¸­çš„æ¯ä¸ªæ•°ç»„ç»„åˆ"
    ],
    "timeComplexity": "O(âˆnáµ¢)",
    "spaceComplexity": "O(âˆnáµ¢)",
    "code": "function cartesianProduct<T>(...arrays: T[][]): T[][] {\n  return arrays.reduce((acc, arr) =>\n    acc.flatMap(x =>\n      arr.map(y => [...x, y])\n    ), [[]]\n  );\n}"
  },
  {
    "id": "permutation",
    "title": "å…¨æ’åˆ—",
    "type": "ç»Ÿè®¡",
    "description": "ç”Ÿæˆæ•°ç»„å…ƒç´ çš„æ‰€æœ‰å¯èƒ½æ’åˆ—",
    "icon": "ğŸ”„",
    "category": "advanced",
    "steps": [
      "1. åŸºçº¿æ¡ä»¶ï¼šé•¿åº¦â‰¤1æ—¶è¿”å›å•å…ƒç´ æ•°ç»„",
      "2. éå†æ¯ä¸ªå…ƒç´ ä½œä¸ºå½“å‰ä½ç½®å€™é€‰",
      "3. é€’å½’ç”Ÿæˆå‰©ä½™å…ƒç´ çš„å…¨æ’åˆ—",
      "4. å°†å½“å‰å…ƒç´ ä¸æ¯ä¸ªæ’åˆ—ç»„åˆ"
    ],
    "timeComplexity": "O(n!)",
    "spaceComplexity": "O(n!)",
    "code": "function permutations<T>(arr: T[]): T[][] {\n  if (arr.length <= 1) return [arr];\n\n  const result: T[][] = [];\n  for (let i = 0; i < arr.length; i++) {\n    const current = arr[i];\n    const remaining = [...arr.slice(0, i), ...arr.slice(i + 1)];\n    const remainingPerms = permutations(remaining);\n    for (const perm of remainingPerms) {\n      result.push([current, ...perm]);\n    }\n  }\n  return result;\n}"
  },
  {
    "id": "sliding-window",
    "title": "æ»‘åŠ¨çª—å£æœ€å¤§å€¼",
    "type": "ç»Ÿè®¡",
    "description": "ä½¿ç”¨åŒç«¯é˜Ÿåˆ—é«˜æ•ˆæ±‚è§£æ»‘åŠ¨çª—å£æœ€å¤§å€¼",
    "icon": "ğŸ“Š",
    "category": "advanced",
    "steps": [
      "1. åˆå§‹åŒ–ç»“æœæ•°ç»„å’ŒåŒç«¯é˜Ÿåˆ—ï¼ˆå­˜ç´¢å¼•ï¼‰",
      "2. éå†æ•°ç»„å…ƒç´ ï¼š",
      "   a. ç§»é™¤è¶Šç•Œçš„é˜Ÿåˆ—å¤´éƒ¨",
      "   b. ä»å°¾éƒ¨ç§»é™¤å°äºå½“å‰å€¼çš„å…ƒç´ ",
      "   c. å°†å½“å‰ç´¢å¼•åŠ å…¥é˜Ÿåˆ—",
      "   d. çª—å£å½¢æˆåè®°å½•é˜Ÿåˆ—å¤´éƒ¨å¯¹åº”å€¼"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(k)",
    "code": "function maxSlidingWindow(nums: number[], k: number): number[] {\n  const result: number[] = [];\n  const deque: number[] = [];\n\n  for (let i = 0; i < nums.length; i++) {\n    if (deque.length > 0 && deque[0] === i - k) {\n      deque.shift();\n    }\n    while (deque.length > 0 && nums[i] >= nums[deque[deque.length - 1]]) {\n      deque.pop();\n    }\n    deque.push(i);\n    if (i >= k - 1) {\n      result.push(nums[deque[0]]);\n    }\n  }\n  return result;\n}"
  },
  {
    "id": "lis",
    "title": "æœ€é•¿é€’å¢å­åºåˆ—",
    "type": "ç»Ÿè®¡",
    "description": "ä½¿ç”¨åŠ¨æ€è§„åˆ’å’ŒäºŒåˆ†æŸ¥æ‰¾é«˜æ•ˆæ±‚è§£æœ€é•¿é€’å¢å­åºåˆ—ã€‚æœ€é•¿é€’å¢å­åºåˆ—è¡¨ç¤ºä¸€ä¸ªåºåˆ—ä¸­æ‰€æœ‰å…ƒç´ éƒ½é€’å¢çš„å­åºåˆ—ã€‚",
    "icon": "ğŸ“ˆ",
    "category": "advanced",
    "steps": [
      "1. åˆå§‹åŒ–tailsæ•°ç»„ï¼ˆå­˜å‚¨é€’å¢åºåˆ—å°¾å…ƒç´ ï¼‰",
      "2. éå†æ¯ä¸ªæ•°å­—ï¼š",
      "   a. äºŒåˆ†æŸ¥æ‰¾æ’å…¥ä½ç½®",
      "   b. æ›¿æ¢tailsä¸­è¯¥ä½ç½®çš„å€¼",
      "   c. è‹¥ä½ç½®åœ¨æœ«å°¾åˆ™æ‰©å±•æ•°ç»„",
      "3. tailsé•¿åº¦å³ä¸ºç»“æœ"
    ],
    "timeComplexity": "O(n log n)",
    "spaceComplexity": "O(n)",
    "code": "function longestIncreasingSubsequence(nums: number[]): number {\n  const tails: number[] = [];\n  for (const num of nums) {\n    let left = 0, right = tails.length;\n    while (left < right) {\n      const mid = Math.floor((left + right) / 2);\n      if (tails[mid] < num) left = mid + 1;\n      else right = mid;\n    }\n    if (left === tails.length) tails.push(num);\n    else tails[left] = num;\n  }\n  return tails.length;\n}"
  },
  {
    "id": "difference-array",
    "title": "å·®åˆ†æ•°ç»„",
    "type": "ç»Ÿè®¡",
    "description": "é«˜æ•ˆå¤„ç†æ•°ç»„åŒºé—´æ›´æ–°æ“ä½œã€‚å·®åˆ†æ•°ç»„è¡¨ç¤ºä¸€ä¸ªåºåˆ—ä¸­æ¯ä¸ªå…ƒç´ ä¸å‰ä¸€ä¸ªå…ƒç´ çš„å·®ã€‚",
    "icon": "ğŸ§®",
    "category": "advanced",
    "steps": [
      "1. æ„é€ å·®åˆ†æ•°ç»„ï¼šdiff[i]=nums[i]-nums[i-1]",
      "2. åŒºé—´æ›´æ–°ï¼š",
      "   a. èµ·å§‹ä½ç½®åŠ å¢é‡",
      "   b. ç»“æŸä½ç½®åä¸€ä½å‡å¢é‡",
      "3. è¿˜åŸæ•°ç»„ï¼šå‰ç¼€å’Œç´¯åŠ diffæ•°ç»„"
    ],
    "timeComplexity": "O(1) æ›´æ–° / O(n) æŸ¥è¯¢",
    "spaceComplexity": "O(n)",
    "code": "class DifferenceArray {\n  private diff: number[];\n\n  constructor(nums: number[]) {\n    this.diff = new Array(nums.length);\n    this.diff[0] = nums[0];\n    for (let i = 1; i < nums.length; i++) {\n      this.diff[i] = nums[i] - nums[i - 1];\n    }\n  }\n\n  increment(start: number, end: number, val: number): void {\n    this.diff[start] += val;\n    if (end + 1 < this.diff.length) {\n      this.diff[end + 1] -= val;\n    }\n  }\n\n  getResult(): number[] {\n    const result = new Array(this.diff.length);\n    result[0] = this.diff[0];\n    for (let i = 1; i < this.diff.length; i++) {\n      result[i] = result[i - 1] + this.diff[i];\n    }\n    return result;\n  }\n}"
  },
  {
    "id": "prefix-sum",
    "title": "å‰ç¼€å’Œæ•°ç»„",
    "type": "ç»Ÿè®¡",
    "description": "é«˜æ•ˆè®¡ç®—æ•°ç»„ä»»æ„åŒºé—´å’Œ",
    "icon": "âˆ‘",
    "category": "advanced",
    "steps": [
      "1. æ„å»ºå‰ç¼€å’Œæ•°ç»„ï¼šprefix[i+1]=prefix[i]+nums[i]",
      "2. åˆå§‹åŒ–prefix[0]=0",
      "3. åŒºé—´å’Œè®¡ç®—ï¼šprefix[j+1]-prefix[i]"
    ],
    "timeComplexity": "O(n) é¢„å¤„ç† / O(1) æŸ¥è¯¢",
    "spaceComplexity": "O(n)",
    "code": "class PrefixSum {\n  private prefix: number[];\n\n  constructor(nums: number[]) {\n    this.prefix = new Array(nums.length + 1).fill(0);\n    for (let i = 0; i < nums.length; i++) {\n      this.prefix[i + 1] = this.prefix[i] + nums[i];\n    }\n  }\n\n  queryRange(i: number, j: number): number {\n    return this.prefix[j + 1] - this.prefix[i];\n  }\n}"
  },
  {
    "id": "quickselect",
    "title": "å¿«é€Ÿé€‰æ‹©ç®—æ³•",
    "type": "ç»Ÿè®¡",
    "description": "é«˜æ•ˆæŸ¥æ‰¾æ•°ç»„ä¸­ç¬¬Kå¤§çš„å…ƒç´ ã€‚å¿«é€Ÿé€‰æ‹©ç®—æ³•æ˜¯å¿«é€Ÿæ’åºçš„å˜ç§ï¼Œç”¨äºåœ¨æœªæ’åºçš„æ•°ç»„ä¸­æ‰¾åˆ°ç¬¬Kå¤§çš„å…ƒç´ ã€‚",
    "icon": "âš¡",
    "category": "advanced",
    "steps": [
      "1. ç¡®å®šç›®æ ‡ç´¢å¼•ï¼ˆç¬¬kå¤§â†’n-kï¼‰",
      "2. é€’å½’åˆ†åŒºï¼š",
      "   a. é€‰å–åŸºå‡†åˆ†åŒºæ•°ç»„",
      "   b. æ ¹æ®åˆ†åŒºç´¢å¼•ä¸ç›®æ ‡ä½ç½®å…³ç³»",
      "   c. é€‰æ‹©å·¦/å³åˆ†åŒºé€’å½’",
      "3. åˆ†åŒºå‡½æ•°ï¼š",
      "   a. é€‰å–å³ç«¯ä¸ºåŸºå‡†",
      "   b. ç§»åŠ¨å°äºåŸºå‡†çš„å…ƒç´ ",
      "   c. äº¤æ¢åŸºå‡†åˆ°æ­£ç¡®ä½ç½®"
    ],
    "timeComplexity": "å¹³å‡ O(n) / æœ€å·® O(nÂ²)",
    "spaceComplexity": "O(1)",
    "code": "function findKthLargest(nums: number[], k: number): number {\n  const indexToFind = nums.length - k;\n  return quickSelect(nums, 0, nums.length - 1, indexToFind);\n}\n\nfunction quickSelect(arr: number[], left: number, right: number, indexToFind: number): number {\n  const partitionIndex = partition(arr, left, right);\n  if (partitionIndex === indexToFind) return arr[partitionIndex];\n  if (partitionIndex < indexToFind)\n    return quickSelect(arr, partitionIndex + 1, right, indexToFind);\n  else\n    return quickSelect(arr, left, partitionIndex - 1, indexToFind);\n}\n\nfunction partition(arr: number[], left: number, right: number): number {\n  const pivot = arr[right];\n  let partitionIndex = left;\n  for (let j = left; j < right; j++) {\n    if (arr[j] < pivot) {\n      [arr[partitionIndex], arr[j]] = [arr[j], arr[partitionIndex]];\n      partitionIndex++;\n    }\n  }\n  [arr[partitionIndex], arr[right]] = [arr[right], arr[partitionIndex]];\n  return partitionIndex;\n}"
  },
  {
    "id": "array-shuffle",
    "title": "æ•°ç»„æ´—ç‰Œ",
    "type": "å˜æ¢",
    "description": "ä½¿ç”¨Fisher-Yatesç®—æ³•é«˜æ•ˆéšæœºæ‰“ä¹±æ•°ç»„é¡ºåº",
    "icon": "ğŸ²",
    "category": "advanced",
    "steps": [
      "1. ä»åå‘å‰éå†æ•°ç»„",
      "2. ä¸ºæ¯ä¸ªä½ç½®ç”Ÿæˆéšæœºç´¢å¼•(0åˆ°å½“å‰ä½ç½®)",
      "3. äº¤æ¢å½“å‰å…ƒç´ ä¸éšæœºä½ç½®å…ƒç´ "
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function shuffleArray<T>(arr: T[]): T[] {\n  const result = [...arr];\n  for (let i = result.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [result[i], result[j]] = [result[j], result[i]];\n  }\n  return result;\n}"
  },
  {
    "id": "array-group",
    "title": "æ•°ç»„åˆ†ç»„",
    "type": "åˆ†ç±»",
    "description": "æ ¹æ®æŒ‡å®šé”®å‡½æ•°å°†æ•°ç»„å…ƒç´ åˆ†ç»„åˆ°å­—å…¸å¯¹è±¡",
    "icon": "ğŸ—‚ï¸",
    "category": "advanced",
    "steps": [
      "1. åˆå§‹åŒ–ç©ºå¯¹è±¡ä½œä¸ºç»“æœå®¹å™¨",
      "2. éå†æ•°ç»„çš„æ¯ä¸ªå…ƒç´ ",
      "3. ä½¿ç”¨é”®å‡½æ•°è®¡ç®—åˆ†ç»„é”®",
      "4. å°†å…ƒç´ æ·»åŠ åˆ°å¯¹åº”åˆ†ç»„æ•°ç»„"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(n)",
    "code": "function groupBy<T>(arr: T[], keyFunc: (item: T) => string): Record<string, T[]> {\n  return arr.reduce((acc, item) => {\n    const key = keyFunc(item);\n    if (!acc[key]) acc[key] = [];\n    acc[key].push(item);\n    return acc;\n  }, {} as Record<string, T[]>);\n}"
  },
  {
    "id": "array-max-subarray",
    "title": "æœ€å¤§å­æ•°ç»„å’Œ",
    "type": "ç»Ÿè®¡",
    "description": "ä½¿ç”¨Kadaneç®—æ³•æŸ¥æ‰¾è¿ç»­å­æ•°ç»„çš„æœ€å¤§å’Œ",
    "icon": "ğŸ“Š",
    "category": "advanced",
    "steps": [
      "1. åˆå§‹åŒ–å½“å‰å’Œä¸æœ€å¤§å’Œä¸ºç¬¬ä¸€ä¸ªå…ƒç´ ",
      "2. éå†æ•°ç»„(ä»ç¬¬äºŒä¸ªå…ƒç´ å¼€å§‹)",
      "3. æ›´æ–°å½“å‰å’Œ(å–å½“å‰å…ƒç´ æˆ–å½“å‰å’Œ+å½“å‰å…ƒç´ )",
      "4. æ›´æ–°æœ€å¤§å’Œ(å–å½“å‰å’Œä¸ä¹‹å‰æœ€å¤§å’Œçš„è¾ƒå¤§å€¼)"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function maxSubarraySum(nums: number[]): number {\n  if (nums.length === 0) return 0;\n  \n  let currentSum = nums[0];\n  let maxSum = nums[0];\n  \n  for (let i = 1; i < nums.length; i++) {\n    currentSum = Math.max(nums[i], currentSum + nums[i]);\n    maxSum = Math.max(maxSum, currentSum);\n  }\n  \n  return maxSum;\n}"
  },
  {
    "id": "array-spiral",
    "title": "èºæ—‹çŸ©é˜µ",
    "type": "å˜æ¢",
    "description": "å°†äºŒç»´æ•°ç»„æŒ‰èºæ—‹é¡ºåºè½¬æ¢ä¸ºä¸€ç»´æ•°ç»„",
    "icon": "ğŸŒ€",
    "category": "advanced",
    "steps": [
      "1. åˆå§‹åŒ–æ–¹å‘(å³ã€ä¸‹ã€å·¦ã€ä¸Š)å’Œè¾¹ç•Œ",
      "2. æŒ‰å½“å‰æ–¹å‘éå†ç›´åˆ°è¾¹ç•Œ",
      "3. è°ƒæ•´è¾¹ç•Œå¹¶åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªæ–¹å‘",
      "4. é‡å¤ç›´åˆ°æ‰€æœ‰å…ƒç´ éå†å®Œæˆ"
    ],
    "timeComplexity": "O(m*n)",
    "spaceComplexity": "O(m*n)",
    "code": "function spiralOrder(matrix: number[][]): number[] {\n  if (matrix.length === 0) return [];\n  \n  const result: number[] = [];\n  let top = 0, bottom = matrix.length - 1;\n  let left = 0, right = matrix[0].length - 1;\n  \n  while (top <= bottom && left <= right) {\n    // Traverse right\n    for (let i = left; i <= right; i++) {\n      result.push(matrix[top][i]);\n    }\n    top++;\n    \n    // Traverse down\n    for (let i = top; i <= bottom; i++) {\n      result.push(matrix[i][right]);\n    }\n    right--;\n    \n    if (top <= bottom) {\n      // Traverse left\n      for (let i = right; i >= left; i--) {\n        result.push(matrix[bottom][i]);\n      }\n      bottom--;\n    }\n    \n    if (left <= right) {\n      // Traverse up\n      for (let i = bottom; i >= top; i--) {\n        result.push(matrix[i][left]);\n      }\n      left++;\n    }\n  }\n  \n  return result;\n}"
  },
  {
    "id": "array-rainwater",
    "title": "æ¥é›¨æ°´é—®é¢˜",
    "type": "ç»Ÿè®¡",
    "description": "è®¡ç®—æŸ±å­ä¹‹é—´èƒ½å®¹çº³çš„é›¨æ°´é‡",
    "icon": "ğŸŒ§ï¸",
    "category": "advanced",
    "steps": [
      "1. åˆå§‹åŒ–å·¦å³æŒ‡é’ˆå’Œå·¦å³æœ€å¤§é«˜åº¦",
      "2. å½“å·¦æŒ‡é’ˆå°äºå³æŒ‡é’ˆæ—¶å¾ªç¯",
      "3. æ›´æ–°å·¦å³ä¸¤ä¾§æœ€å¤§é«˜åº¦",
      "4. æ ¹æ®è¾ƒå°é«˜åº¦è®¡ç®—å½“å‰å¯å­˜æ°´é‡",
      "5. ç§»åŠ¨è¾ƒå°é«˜åº¦å¯¹åº”çš„æŒ‡é’ˆ"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function trapRainwater(heights: number[]): number {\n  let left = 0, right = heights.length - 1;\n  let leftMax = 0, rightMax = 0;\n  let water = 0;\n  \n  while (left < right) {\n    if (heights[left] < heights[right]) {\n      if (heights[left] >= leftMax) {\n        leftMax = heights[left];\n      } else {\n        water += leftMax - heights[left];\n      }\n      left++;\n    } else {\n      if (heights[right] >= rightMax) {\n        rightMax = heights[right];\n      } else {\n        water += rightMax - heights[right];\n      }\n      right--;\n    }\n  }\n  \n  return water;\n}"
  },
  {
    "id": "array-product",
    "title": "é™¤è‡ªèº«å¤–çš„ä¹˜ç§¯",
    "type": "å˜æ¢",
    "description": "è®¡ç®—æ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ é™¤è‡ªèº«å¤–æ‰€æœ‰å…ƒç´ çš„ä¹˜ç§¯",
    "icon": "âœ–ï¸",
    "category": "advanced",
    "steps": [
      "1. åˆå§‹åŒ–ç»“æœæ•°ç»„å’Œå·¦å³ä¹˜ç§¯å˜é‡",
      "2. ä»å·¦å‘å³éå†è®¡ç®—å·¦ä¾§ä¹˜ç§¯",
      "3. ä»å³å‘å·¦éå†è®¡ç®—å³ä¾§ä¹˜ç§¯",
      "4. åˆå¹¶å·¦å³ä¹˜ç§¯å¾—åˆ°æœ€ç»ˆç»“æœ"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function productExceptSelf(nums: number[]): number[] {\n  const n = nums.length;\n  const result = new Array(n);\n  \n  // è®¡ç®—å·¦ä¾§ä¹˜ç§¯\n  result[0] = 1;\n  for (let i = 1; i < n; i++) {\n    result[i] = result[i - 1] * nums[i - 1];\n  }\n  \n  // è®¡ç®—å³ä¾§ä¹˜ç§¯å¹¶åˆå¹¶\n  let rightProduct = 1;\n  for (let i = n - 1; i >= 0; i--) {\n    result[i] *= rightProduct;\n    rightProduct *= nums[i];\n  }\n  \n  return result;\n}"
  },
  {
    "id": "array-missing-positive",
    "title": "ç¼ºå¤±çš„ç¬¬ä¸€ä¸ªæ­£æ•°",
    "type": "æŸ¥æ‰¾",
    "description": "åœ¨æœªæ’åºæ•°ç»„ä¸­æŸ¥æ‰¾ç¼ºå¤±çš„æœ€å°æ­£æ•´æ•°",
    "icon": "ğŸ”",
    "category": "advanced",
    "steps": [
      "1. å¤„ç†éæ­£æ•°å…ƒç´ (è®¾ä¸ºn+1)",
      "2. éå†æ•°ç»„æ ‡è®°å­˜åœ¨å…ƒç´ (ç´¢å¼•å¯¹åº”å€¼å–è´Ÿ)",
      "3. æŸ¥æ‰¾ç¬¬ä¸€ä¸ªæœªæ ‡è®°çš„æ­£æ•°ç´¢å¼•",
      "4. è‹¥éƒ½æ ‡è®°åˆ™è¿”å›n+1"
    ],
    "timeComplexity": "O(n)",
    "spaceComplexity": "O(1)",
    "code": "function firstMissingPositive(nums: number[]): number {\n  const n = nums.length;\n  \n  // å°†æ‰€æœ‰éæ­£æ•°æ ‡è®°ä¸ºn+1\n  for (let i = 0; i < n; i++) {\n    if (nums[i] <= 0) {\n      nums[i] = n + 1;\n    }\n  }\n  \n  // æ ‡è®°å­˜åœ¨çš„æ­£æ•°\n  for (let i = 0; i < n; i++) {\n    const num = Math.abs(nums[i]);\n    if (num <= n) {\n      nums[num - 1] = -Math.abs(nums[num - 1]);\n    }\n  }\n  \n  // æŸ¥æ‰¾ç¬¬ä¸€ä¸ªæœªæ ‡è®°çš„æ­£æ•°\n  for (let i = 0; i < n; i++) {\n    if (nums[i] > 0) {\n      return i + 1;\n    }\n  }\n  \n  return n + 1;\n}"
  }
]
